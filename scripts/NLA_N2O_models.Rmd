---
title: "Modeling workflow: NLA N2O survey data"
author: "Roy Martin, Jake Beaulieu, Michael McManus"
date: "`r Sys.Date()`"
output:
  github_document:
    number_sections: TRUE
    df_print: "tibble"
    math_method: 
      engine: webtex
      url: https://latex.codecogs.com/svg.image?
    html_preview: TRUE
    keep_html: TRUE
bibliography: RWM_Endnote_Library.bib
link-citations: yes
editor_options:
  chunk_output_type: inline
---

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
library(ggpubr)
library(moments)
library(ggplot2)
library(ggExtra)
library(gridExtra)
library(kableExtra)
library(ggrepel)
library(dplyr)
library(tidyverse)
library(tidyr)
library(future)
library(foreach)
library(itertools)
library(bayesplot)
library(tidybayes)
library(brms)
library(tictoc)
library(arrow)

options(mc.cores = parallel::detectCores(logical = FALSE))
options( max.print = 1000 )

# Identify local path for each user
localPath <- Sys.getenv("USERPROFILE")

# Define helper functions
# standardized formatting for column names
toEPA <- function(X1){
  names(X1) = tolower(names(X1))
  names(X1) = gsub(pattern = c("\\(| |#|)|/|-|\\+|:|_"), replacement = ".", x = names(X1))
  X1
}

# stat: skew 
skew <- function(x) {
  xdev <- x - mean(x)
  n <- length(x)
  r <- sum(xdev^3) / sum(xdev^2)^1.5
  return(r * sqrt(n) * (1 - 1/n)^1.5)
}

# Load model and data files for knitting (if they already exist)
f1 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/dg.rda"
f2 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/df_model.rda"
f3 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/df_test.rda"
f4 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sframe.rda"
f5 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/pframe.rda"
f6 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/samp_props.rda"

f7 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod1.rda"
f8 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod2.rda"
f9 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod3.rda"
f10 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod4.rda"
f11 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod5.rda"
f12 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod6.rda"
f13 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/all_predictions_b.rda"
f14 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sframe.rda"
f15 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/pframe.rda"
f16 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_survey_ests.rda"
f17 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_survey_ests_size.rda"
f18 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sat_survey_ests.rda"
f19 <- "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sat_survey_ests_size.rda"

if(file.exists(f1))
  load(f1)
if(file.exists(f2))
  load(f2)
if(file.exists(f3))
  load(f3)
if(file.exists(f4))
  load(f4)
if(file.exists(f5))
  load(f5)
if(file.exists(f6))
  load(f6)
if(file.exists(f7))
  load(f7)
if(file.exists(f8))
  load(f8)
if(file.exists(f9))
  load(f9)
if(file.exists(f10))
  load(f10)
if(file.exists(f11))
  load(f11)
if(file.exists(f12))
  load(f12)
if(file.exists(f13))
  load(f13)
if(file.exists(f14))
  load(f14)
if(file.exists(f15))
  load(f15)
if(file.exists(f16))
  load(f16)
if(file.exists(f17))
  load(f17)
if(file.exists(f18))
  load(f18)
if(file.exists(f19))
  load(f19)
```

# Background and Objectives
This document describes the modeling workflow and results from estimating dissolved and equilibrium N2O gas concentrations and saturation ratios for all freshwater waterbodies (natural and man-made lakes and reservoirs) in the lower 48 US states larger than 1 ha. Data for these estimates came from the 2017 Nation Lakes Assessment (NLA) survey, wherein a subset of waterbodies were sampled from the broader population of interest (POI) according to a spatially balanced, stratified, and unequal probability design. Stratification was among categories of lake size (surface area in hectares), WSA9 ecoregion, and US state (excluding AK and HI). In order to better capture variability among the wide range of lake sizes in the POI, larger lakes were intentionally over-sampled relative to smaller lakes.

To make inferences back to the POI from this sample, estimates needed to be adjusted in a manner that addressed potential biases related to the relative representation of waterbody characteristics in the sample compared to the POI, specifically with respect to the survey design variables. It can be helpful to define the complete data likelihood (CDL) when considering how to address biases that may arise from sampling designs [@Link_Barker_2010; @Zachmann_etal_2022]. For the 2017 NLA survey, the complete data would be considered all US lakes and reservoirs in the lower 48 states larger than 1 hectare (_i.e._, the POI). The survey samples, by comparison, could then be considered a subset of that complete data with a known pattern of "missingess" assigned by the survey. In this case, waterbodies in the POI were missing from the sample not completely at random, but according to a probability assigned by the design parameters. This type of missingness is considered not ignorable when making inferences from a sample to a POI [@Gelman_etal_2014, Ch. 8; @Zachmann_etal_2022]. However, _conditional_ on the design variables, the sample could be considered a simple random sample (SRS) from the POI [@Gelman_etal_2014, Ch. 8; @Zachmann_etal_2022]. 

A simple, model-based strategy for adjusting a sample to a POI is to include the survey design variables as predictors in a regression model [@Gelman_etal_2020, Ch. 17]. After fitting the regression, the parameter estimates can be used to make adjustments according to the distribution of the design variables in the POI in a second step referred to as "poststratification" [@Gelman_etal_2020, Ch. 17]. A particularly popular version of this approach uses multilevel regression models and is referred to as multilevel regression with poststratification, or MRP [@Park_etal_2004; @Gelman_Little_1997; @Gelman_etal_2020, Ch. 17; @Kennedy_Gelman_2021]. Multilevel regression models are often recommended because they can provide regularized estimates along the design groupings, which can improve out-of-sample inferences [_e.g._, @Gelman_Little_1997; @Kennedy_Gelman_2021]. Estimates for group levels that may be missing from the sample, but are part of the population of interest, are also straightforward using the multilevel approach [@Gelman_etal_2020 Ch. 17; @McElreath_2020]. For a recent applied example and helpful tutorial employing this approach, see @Kennedy_Gelman_2021. For an example of a recent application in the context of national surveys of environmental resources, see @Zachmann_etal_2022. 

In this study, we used a MRP-like approach to provide population-level estimates based on the 2017 NLA dissolved gas survey data. The remainder of this document provides the workflow, data, models, and code used to make these estimates. To begin, a number of Bayesian multilevel regression models were fit to the sample data. These models were fit and checked against both the data used to construct the models as well as hold-out data from future visits. After evaluating a number of different models, a final model was selected for use in inference. Because total N2O flux estimates needed to be estimated based on individual, waterbody-level measures (_e.g._, surface area), predictions from the model were made to each individual lake in the POI (n = 465,897). These predictions were assumed relevant to average conditions during the biological index period for each lake in 2017. 

The objective of the modeling effort was to provide estimates for (1) dissolved and equilibrium N2O concentrations; (2) the N2O saturation ratio (i.e., dissolved N2O/equilibrium N2O); and (3) the proportion of under-saturated water bodies (i.e., saturation ratio < 1) for the National-level POI and a number of sub-populations therein (_e.g._, ecoregion, state, size category). The gas estimates were also used to estimate the total flux of N2O gas attributable to the target populations. Saturation ratio was calculated as the ratio of dissolved to equilibrium N2O. Because dissolved and equilibrium N2O were observed on the same sample units (sites in lakes), the regression models were fit to their joint distribution and the ratio estimates were assembled as a derived quantity calculated from the joint posterior predictive distribution of those variables. The response variable was, therefore, modeled as multivariate in order to account for any potential statistical dependencies between dissolved and equilibrium N2O due to, for example, common dependencies on geography. Although predictions of the mean marginal probabilities from separate models may have provided comparable estimates, a joint model allowing correlated errors was expected to better capture uncertainty and potentially improve out-of-sample predictions, should the variables be conditionally correlated [@Warton_etal_2015; @Poggiato_etal_2021]. All of the models fit were constructed using the `brms` package [@Burkner_2017] in `R` [@R_Core_Team_2021] as an interface to Stan, a software package for fitting fully Bayesian models via Hamiltonian Monte Carlo [HMC, @Stan_Development_Team_2018_a; @Stan_Development_Team_2018_b; @Stan_Development_Team_2018_c]. More specific details on the model structures is provided throughout the "Model fitting" section below.

# Data
As explained in a previous data munging document document
(https://github.com/USEPA/DissolvedGasNla/blob/master/scripts/dgIndicatorAnalysis.html), duplicate dissolved gas samples were collected at a depth of ~0.1m at designated index sites distributed across 1091 lakes nationwide, of which 95 were sampled twice as repeat visits. This subset of revisit sites was used as a test set for assessing model fit and out-of-sample performance. 

Water samples were analyzed via gas chromotography and concentrations were recorded to the nearest 0.001 nmol/L. As part of the survey design, each gas observation was indexed to an individual lake selected with unequal probability from 5 different lake size categories, $j \in j=1,...,J = 5$, according to surface area (ha), and from within a state, $k \in k=1,...,K = 48$, situated within an aggregated, WSA9 or Omernik ecoregion, $l \in l=1,...,L = 9$. All WSA9 ecoregions were represented, including the Xeric (XER), Western Mountain (WMT),  Northern Plains (NPL), Southern Plains (SPL), Temperate Plains (TPL), Coastal Plains (CPL), Upper Midwest (UMW), Northern Appalachian (NAP), and Southern Appalachian (SAP) regions. Gas data from the first and second (follow-up) visits were separated, with $n=984$ _vs._ $n=95$ observations each. In addition to the design variables, a number of potentially useful covariates were also indexed to the gas observations, including measures of NO3, surface water temperature, elevation, chlorophyll a content, dissolved oxygen content, and waterbody size (hectares). These gas data and covariates were previously described and munged at: https://github.com/USEPA/DissolvedGasNla/blob/master/scripts/dataMunge.html. 

## Import
That originally munged gas dataset was imported below. 

```{r import_data, eval=FALSE, include=TRUE}
load( file = paste0( localPath,
              "/Environmental Protection Agency (EPA)/",
              "ORD NLA17 Dissolved Gas - Documents/",
              "inputData/dg.2021-02-01.RData")
      )

save(dg, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/dg.rda") 
```

A new data frame for modeling was constructed from the original file, including only the variables of interest: (1) the N2O gas observations; (2) the survey design variables indexed to those observations; and (3) additional covariates considered potentially useful for improving the fit and/or practical interpretation of the model. The modeling data frame below excluded the second-visit observations, which would later be used for model checking. Some variables from the imported data were renamed for convenience. In addition, the NO3 covariate was rounded according to the documented measurement precision and an alternative version was created by log-transforming and re-coding the variable as an ordered factor with five levels. The left-most cut point separated observations below the detection limit from the completely observed samples. The remaining cut points were drawn at approximately equal distances in the positive direction along the log scale. Finally, one lake had no N2O gas information and was removed from the data frame.

```{r all_data_n, echo=TRUE, paged.print=TRUE}
dg %>%
  filter(!is.na(dissolved.n2o.nmol)) %>% # 1 obs with missing N2O measurement
  nrow() # number of observations before filtering
```

```{r model_data, eval=FALSE, include=TRUE}
df_model <- dg %>%
  filter(!is.na(dissolved.n2o.nmol)) %>%
  filter(sitetype == "PROB") %>% # probability samples only
  filter(visit.no == 1) %>% # first-visit sites only
  mutate(n2o = round(dissolved.n2o.nmol, 2),
         n2o_eq = round(sat.n2o.nmol, 2),
         n2o_sat = n2o.sat.ratio,
         n2o_em = e.n2o.nmol.d,
         n2o_flux = f.n2o.m.d,
         WSA9 = factor(ag.eco9),
         state = factor(state.abb[match(state.nm, state.name)]),
         area_ha = area.ha,
         log_area = log(area_ha),
         chla = chla.result,
         log_chla = log(chla),
         elev = elevation,
         log_elev = log(elev + 1),
         do_surf = o2.surf,
         log_do = log(do_surf),
         bf_max = max.bf,
         sqrt_bf = sqrt(bf_max),
         size_cat = recode(area.cat6, # simpler naming conventions for the size categories
                           "(1,4]" = "min_4" ,
                           "(10,20]" = "10_20",
                           "(20,50]" = "20_50",
                           "(4,10]" = "4_10",
                           ">50" = "50_max")) %>%
  mutate(size_cat = factor(size_cat,
                           levels = c("min_4", "4_10", "10_20", "20_50", "50_max"),
                           ordered = TRUE)) %>%
  mutate(no3 = ifelse(nitrate.n.result <= 0.0005, 0.0005, round(nitrate.n.result, 4))) %>%# 1/2 mdl 0.01
  mutate(no3_cat = cut(log(no3), # convert no3 to ordered factor with 5 levels
                       breaks = c(-Inf, -7.5, -5.5, -3.5, -1.5, Inf),
                       labels =seq(1, 5, 1))) %>%
  mutate(no3_cat = factor(no3_cat,
                          levels = seq(1, 5, 1),
                          ordered = TRUE)) %>%
  mutate(date = as.Date(date.col)) %>%
  mutate(jdate = as.numeric(format(date, "%j"))) %>% 
  mutate(lat = map.lat.dd,
         lon = map.lon.dd) %>% # longitude
  mutate(surftemp = surftemp,
         log_surftemp = log(surftemp)) %>% 
  select(WSA9,
         state,
         size_cat,
         site.id,
         lat,
         lon,
         date,
         jdate,
         surftemp,
         log_surftemp,
         area_ha,
         log_area,
         elev,
         log_elev,
         chla,
         log_chla,
         do_surf,
         log_do,
         bf_max,
         sqrt_bf,
         n2o,
         n2o_eq,
         no3,
         no3_cat
         )

save(df_model, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/df_model.rda") 
```

A preview showing the first 10 rows of the modeling data:

```{r model_data_print, echo=TRUE, paged.print=TRUE}
nrow(df_model) # number of obs after filtering

df_model %>%
  head(10)
```

A second data frame, including only the second visit observations was constructed below. These data were later used as a "test set" to assess the out-of-sample performance of the model developed on the first-visit or "training set".

```{r all_data_n_2, echo=TRUE, paged.print=TRUE}
# number of observations before filtering probability samples
dg %>%
  filter(!is.na(dissolved.n2o.nmol)) %>% # remove obs with missing response measurements
  nrow()
```

```{r test_data, eval=FALSE, include=TRUE}
df_test <- dg %>%
  filter(!is.na(dissolved.n2o.nmol)) %>%
  filter(sitetype == "PROB") %>% # probability samples only
  filter(visit.no == 2) %>% # second-visit sites only
  mutate(n2o = round(dissolved.n2o.nmol, 2),
         n2o_eq = round(sat.n2o.nmol, 2),
         n2o_sat = n2o.sat.ratio,
         n2o_em = e.n2o.nmol.d,
         n2o_flux = f.n2o.m.d,
         WSA9 = factor(ag.eco9),
         state = factor(state.abb[match(state.nm, state.name)]),
         area_ha = area.ha,
         log_area = log(area_ha),
         chla = chla.result,
         log_chla = log(chla),
         elev = elevation,
         log_elev = log(elev + 1),
         do_surf = o2.surf,
         log_do = log(do_surf),
         bf_max = max.bf,
         sqrt_bf = sqrt(bf_max),
         size_cat = recode(area.cat6, # simpler naming conventions for the size categories
                           "(1,4]" = "min_4" ,
                           "(10,20]" = "10_20",
                           "(20,50]" = "20_50",
                           "(4,10]" = "4_10",
                           ">50" = "50_max")) %>%
  mutate(size_cat = factor(size_cat,
                           levels = c("min_4", "4_10", "10_20", "20_50", "50_max"),
                           ordered = TRUE)) %>%
  mutate(no3 = ifelse(nitrate.n.result <= 0.0005, 0.0005, round(nitrate.n.result, 4))) %>%# 1/2 mdl 0.01
  mutate(no3_cat = cut(log(no3), # convert no3 to ordered factor with 5 levels
                       breaks = c(-Inf, -7.5, -5.5, -3.5, -1.5, Inf),
                       labels =seq(1, 5, 1))) %>%
  mutate(no3_cat = factor(no3_cat,
                          levels = seq(1, 5, 1),
                          ordered = TRUE)) %>%
  mutate(date = as.Date(date.col)) %>%
  mutate(jdate = as.numeric(format(date, "%j"))) %>% 
  mutate(lat = map.lat.dd,
         lon = map.lon.dd) %>% # longitude
  mutate(surftemp = surftemp,
         log_surftemp = log(surftemp)) %>% 
  select(WSA9,
         state,
         size_cat,
         site.id,
         lat,
         lon,
         date,
         jdate,
         surftemp,
         log_surftemp,
         area_ha,
         log_area,
         elev,
         log_elev,
         chla,
         log_chla,
         do_surf,
         log_do,
         bf_max,
         sqrt_bf,
         n2o,
         n2o_eq,
         no3,
         no3_cat
         )

save(df_test, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/df_test.rda") 
```

A preview of the first 10 rows of the test data:

```{r test_data_print, echo=TRUE, paged.print=TRUE}
nrow(df_test) # number of obs after filtering for probability samples, first visits, and removing one site missing ecoregion (WSA9) info.

df_test %>%
  head(10)
```

## Target population

Below. the original NLA sampling frame was imported and filtered to include only lakes in the POI. The resulting target population included a total of 465,897 waterbodies.

```{r import_sample_frame, eval=FALSE, include=TRUE}
df_pop <- read.csv(file = paste0(localPath,
              "/Environmental Protection Agency (EPA)/",
              "ORD NLA17 Dissolved Gas - Documents/",
              "inputData/NLA_Sample_Frame.csv"), header = T)

sframe <- df_pop %>%
  filter(nla17_sf != "Exclude2017") %>%
  filter(nla17_sf != "Exclude2017_Include2017NH") %>%
  filter(state != "DC") %>%
  filter(state != "HI") %>%
  droplevels() %>%
  mutate(WSA9 = factor(ag_eco9),
         WSA9 = forcats::fct_drop(WSA9), # remove NA level
         state = factor(state),
         size_cat = factor(area_cat6),
         lat = lat_dd83,
         lon = lon_dd83,
         log_area = log(area_ha),
         elev = elevation,
         log_elev = ifelse(elev <= 0, 0, elev), # assumed elev < 0 to be elev = 0
         log_elev = log(log_elev + 1)
         ) %>% 
  mutate(size_cat = recode(size_cat, 
                           "(1,4]" = "min_4" ,
                           "(10,20]" = "10_20",
                           "(20,50]" = "20_50",
                           "(4,10]" = "4_10",
                           ">50" = "50_max")) %>%
  mutate(size_cat = factor(size_cat, 
                           levels = c("min_4", "4_10", "10_20", "20_50", "50_max"),
                           ordered = TRUE)) %>%
  select(WSA9, state, size_cat, lat, lon, area_ha, log_area, elev, log_elev)

rm(df_pop)

save(sframe, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sframe.rda") 
```

Below is a sample of the first ten rows describing the POI:

```{r sample_frame_print, echo=TRUE, paged.print=TRUE}
sframe %>%
  head(10)
```

Cross tabulations below show the structure of the target population with respect to the survey design variables. The cross-tabulation shows that each ecoregion does not contain each state. Therefore, states were nested within ecoregions.

```{r frame_dimensions_1, echo=TRUE, message=FALSE}
sframe %>%
  group_by(WSA9, state) %>%
  summarise(n = n(), .groups = "drop") %>%
  spread(state, n) %>%
  head(10)
```

The cross-tablulation below indicates that lake size category was nested within state (which was nested in ecoregion). That is, not every ecoregion:state contained every size category.

```{r frame_dimensions_4, echo=TRUE, message=FALSE}
sframe %>%
  group_by(WSA9, state, size_cat) %>%
  summarise(n = n(), .groups = "drop") %>%
  spread(size_cat, n) %>%
  head(10)
```

Below, the sampling frame was used to create a typical post-stratification table. There were 536 "types" or groupings of lakes in the POI with respect to the sampling design. The total counts of those lake types (n_lakes) and their proportions (prop_cell) relative to the counts in the target population were tabulated.

```{r filter_frame, eval=FALSE, include=TRUE}
pframe <- sframe %>%
  mutate(obs = 1) %>%
  group_by(WSA9, state, size_cat) %>%
  summarise(n_lakes = sum(obs), .groups = "drop") %>%
  ungroup() %>%
  mutate(prop_cell = n_lakes/sum(n_lakes)) %>%
  mutate(type = "population") 

save(pframe, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/pframe.rda")
```

```{r filter_frame_print}
pframe %>%
  head(10)
```

## Sample vs. population

Below, the distribution of waterbody types in the POI were compared to their proportions in the observed sample. There were 352 waterbody types in the sample compared to the 536 in the POI. There were 984 observations distributed across these 352 lake types in the sample; and the number of samples was not distributed evenly across the types. Some cells were represented by as few as 1 lake. In total, 536-352 = 184 lake types in the population of interest were not represented in the sample.

```{r sample_cell_counts, eval=FALSE, include=TRUE}
samp_props <- df_model %>%
  mutate(obs = 1) %>%
  group_by(WSA9, state, size_cat) %>%
  summarize(n_lakes = sum(obs), .groups = "drop") %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes / sum(n_lakes), 7)) %>%
  mutate(type = "sample") 

save(samp_props, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/samp_props.rda")
```

```{r sample_cell_count_print, echo=TRUE, paged.print=TRUE}
samp_props %>%
  print()
```

Below, a graphical comparison was constructed to depict the distribution of cells in the POI _vs._ those in the sample.

```{r compare_sample_pop_cells, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10}
pframe %>%
  bind_rows(samp_props) %>%
  ggplot(aes(x = interaction(WSA9, state, size_cat), y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes( shape = type, color = type)) +
  geom_line() +
  theme_tidybayes() +
  theme(axis.text.x = element_blank()) +
  xlab("WSA9:state:size") +
  ylab("proportion in cell")
```

Another comparison between population and sample was constructed by ecoregion below. Lakes in the Coastal Plains (CPL) ecoregion, for example, were clearly undersampled relative to their proportion of the population.

```{r eco_props_pop, fig.align='center', fig.asp=0.5, fig.width=10}
pframe_eco <- pframe %>%
  group_by(WSA9) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'population') 

samp_props_eco <- samp_props %>%
  group_by(WSA9) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'sample')

pframe_eco %>%
  bind_rows(samp_props_eco) %>%
  ggplot(mapping = aes(x = WSA9, y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes( shape = type, color = type), size = 3) +
  geom_line() +
  theme_tidybayes() +
  xlab("Ecoregion") +
  ylab("proportion in cell") + 
  theme(legend.position = "top",
        legend.title = element_blank(),
        legend.text = element_text(size = 14)) +
  theme(text = element_text(size = 12))
```

A similar comparison by state was constructed below.

```{r state_props_pop, fig.align='center', fig.asp=0.5, fig.width=10}
pframe_state <- pframe %>%
  group_by(state) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'population')

samp_props_state <- samp_props %>%
  group_by(state) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'sample')

pframe_state %>%
  bind_rows(samp_props_state) %>%
  ggplot(mapping = aes(x = state, y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes(shape = type, color = type)) +
  geom_line() +
  theme_tidybayes() +
  theme(axis.text.x = element_text(angle = 45)) +
  xlab("State") +
  ylab("proportion in cell")
```

Finally, a comparison by NLA size category is shown below. Waterbodies of the smallest size category were heavily under-sampled relative to the POI and those from the larger size categories were over-sampled.

```{r size_props_pop, fig.align='center', fig.asp=0.5, fig.width=10}
pframe_size <- pframe %>%
  group_by(size_cat) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'population')

samp_props_size <- samp_props %>%
  group_by(size_cat) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'sample')

pframe_size %>%
  bind_rows(samp_props_size) %>%
  ggplot(mapping = aes(x = size_cat, y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes( shape = type, color = type)) +
  geom_line() +
  theme_tidybayes() +
  xlab("Size category") +
  ylab("proportion in cell")
```

## Sample-based estimates

Below are (naive) estimates, based only on the sample, for national means for dissolved and equilibrium N2O and the saturation ratio.

Dissolved N2O:

```{r sample_summary_n2o}
df_model %>%
  summarise(mean = mean(n2o),
             sd = sd(n2o)) %>%
  print()
```

Equilibrium N2O:

```{r sample_summary_n2oeq}
df_model %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  print()
```

Saturation ratio:

```{r sample_summary_n2osat}
df_model %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  print()
```

Roughly 67% of lakes in the sample were under-saturated (i.e., saturation ratio < 1):

```{r sample_summary_propsat}
df_model %>%
  summarise(prop_undersat = sum((n2o / n2o_eq) < 1) / 984) %>%
  print()
```

Using only the sample observations again, a plot was constructed of the overall mean (dashed line) along with the ecoregion-specific means (black circles). The shaded areas indicate +/- 1 standard deviation. Neither dissolved N2O nor the saturation ratio were clearly structured by ecoregion in the sample, but there did appear to be some potential structure along this variable in the equilibrium N2O observations.

```{r sample_summary_eco, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  group_by(WSA9) %>%
  summarise(mean = mean(n2o),
             sd = sd( n2o)) %>%
  ggplot(aes(x = WSA9, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = WSA9), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = WSA9, y = mean))+
  geom_point()+
  geom_hline(yintercept = 8.72, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) + 
  ylab("") +
  ggtitle("N2O")

p2 <- df_model %>%
  group_by(WSA9) %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  ggplot(aes(x = WSA9, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = WSA9), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = WSA9, y = mean))+
  geom_point()+
  geom_hline(yintercept = 7.48, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) +
  ylab("Sample mean") +
  ggtitle("N2O equilibrium")

p3 <- df_model %>%
  group_by(WSA9) %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  ggplot(aes(x = WSA9, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = WSA9), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = WSA9, y = mean))+
  geom_point()+
  geom_hline(yintercept = 1.17, linetype = 'dashed') +
  theme_tidybayes() +  
  xlab("Ecoregion") +
  ylab("") +
  ggtitle("N2O saturation ratio")

grid.arrange(p1, p2, p3)
```

The same summary by state is below.

```{r sample_summary_state, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  group_by(state) %>%
  summarise(mean = mean(n2o),
             sd = sd( n2o)) %>%
  ggplot(aes(x = state, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = state), 
              fill = 'lightgrey', 
              alpha = .7) +
  geom_line(aes(x = state, y = mean))+
  geom_point()+
  geom_hline(yintercept = 8.72, linetype = 'dashed') + 
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) + 
  ylab("") +
  ggtitle("N2O")

p2 <- df_model %>%
  group_by(state) %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  ggplot(aes(x = state, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = state), 
              fill = 'lightgrey', 
              alpha = .7) +
  geom_line(aes(x = state, y = mean))+
  geom_point()+
  geom_hline(yintercept = 7.48, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) +
  ylab("Sample mean") +
  ggtitle("N2O equilibrium")

p3 <- df_model %>%
  group_by(state) %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  ggplot(aes(x = state, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = state), 
              fill = 'lightgrey', 
              alpha = .7)+
  geom_line(aes(x = state, y = mean))+
  geom_point()+
  geom_hline(yintercept = 1.17, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.text.x = element_text(angle = 45)) + 
  xlab("State") +
  ylab("") +
  ggtitle("N2O saturation ratio")

grid.arrange(p1, p2, p3)
```

Finally, the same summary by size category.

```{r sample_summary_size, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  group_by(size_cat) %>%
  summarise(mean = mean(n2o),
             sd = sd( n2o)) %>%
  ggplot(aes(x = size_cat, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = size_cat), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = size_cat, y = mean))+
  geom_point()+
  geom_hline(yintercept = 8.72, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) + 
  ylab("") +
  ggtitle("N2O")

p2 <- df_model %>%
  group_by(size_cat) %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  ggplot(aes(x = size_cat, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = size_cat), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = size_cat, y = mean))+
  geom_point()+
  geom_hline(yintercept = 7.48, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) +
  ylab("Sample mean") +
  ggtitle("N2O equilibrium")

p3 <- df_model %>%
  group_by(size_cat) %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  ggplot(aes(x = size_cat, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = size_cat), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = size_cat, y = mean))+
  geom_point()+
  geom_hline(yintercept = 1.17, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.text.x = element_text(angle = 45)) + 
  xlab("Size class") +
  ylab("") +
  ggtitle("N2O saturation ratio")

grid.arrange(p1, p2, p3)
```

## Sample data exploration

Below, the distribution N2O concentrations for the sample was summarized using a density and rug plot. Note the natural log scale of the x-axis. Both the dissolved and equilibrium N2O data had considerable right skew even after the log transformation. This was not unexpected and has been noted in other studies [_e.g._, @Webb_etal_2019]. The saturation ratio was also skewed (sat_ratio = n2o / n2o_eq).

```{r summary_N2O, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  ggplot(aes(x = n2o)) +
  geom_boxplot(aes(x = n2o, y = -0.5), outlier.shape = NA, alpha = 0.7) + 
  geom_density(aes(x = n2o)) +
  geom_rug(aes(x = n2o), show.legend = F ) +
  theme(text = element_text(size=12)) +
  scale_x_continuous(trans = "log", breaks = c(0, 5, 10, 25, 50, 150)) +
  ylab("density") +
  xlab("N2O (nmol/L)") +
  theme_tidybayes() +
  theme(axis.text.y = element_blank())

p2 <- df_model %>%
  ggplot(aes(x = n2o_eq)) +
  geom_boxplot(aes(x = n2o_eq, y = -0.5), outlier.shape = NA, alpha = 0.7) + 
  geom_density(aes(x = n2o_eq)) +
  geom_rug(aes(x = n2o_eq), show.legend = F ) +
  theme(text = element_text(size=12)) +
  scale_x_continuous(trans = "log") +
  ylab("density") +
  xlab("Equilibrium N2O (nmol/L)") +
  theme_tidybayes() +
  theme(axis.text.y = element_blank())

p3 <- df_model %>%
  ggplot(aes(x = n2o / n2o_eq)) +
  geom_boxplot(aes(x = n2o / n2o_eq, y = -0.5), outlier.shape = NA, alpha = 0.7) + 
  geom_density(aes(x = n2o / n2o_eq)) +
  geom_rug(aes(x = n2o / n2o_eq), show.legend = F ) +
  theme(text = element_text(size=12)) +
  scale_x_continuous(trans = "log", breaks = c(0, 1, 5, 10, 20)) +
  ylab("density") +
  xlab("N2O saturation ratio") +
  theme_tidybayes() +
  theme(axis.text.y = element_blank())

grid.arrange(p1, p2, p3)
```

Below are plots of dissolved N2O vs. NO3. The first plot shows log(N2O) vs. log(NO3), as well as the ordinal categories assigned to NO3 (vertical lines). The leftmost vertical line is dashed and separates the NO3 observations below the detection limit. The trend is increasing and nonlinear on the log scale, with increasing variance in N2O as NO3 increased.

```{r summary_N2O_vs_NO3, echo=FALSE, fig.align='center', fig.height=4, fig.width=6, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  geom_vline(xintercept = -7.5, linetype = "dashed") +
  geom_vline(xintercept = -5.5) +
  geom_vline(xintercept = -3.5) +
  geom_vline(xintercept = -1.5) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

Below are plots of dissolved N2O vs. NO3 for 6 quantiles of the surface temperature measurements (quantiles increasing from 1 to 6). This plot suggested that the NO3 effect on N2O may have been stronger in lakes with higher observed temperatures.

```{r summary_N2O_vs_NO3_surftemp, echo=FALSE, fig.align='center', fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(surftemp, 6))) +
  theme_bw()
```

The next plot below shows the relationship between dissolved N2O and NO3 at 6 different quantiles (increasing 1 to 6) of the log-scaled lake surface area estimates.

```{r summary_N2O_vs_NO3_logarea, echo=FALSE, fig.align='center', fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(log_area, 6))) +
  theme_bw()
```

Similar plots are below, but with NO3 expressed as an ordered categorical variable with 5 levels. The positive and monotonic trends area similar to the previous plots where NO3 was treated as continuous. Note the large number of observations in the first NO3 category (no3_cat = 1). This category represented all of the observations for NO3 that were below the detection limit, which was most of the data.

```{r summary_N2O_vs_NO3cat, echo=FALSE, fig.align='center', fig.height=4, fig.width=6, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(outlier.shape = NA, notch = TRUE, color = "black", alpha = 0.7) +
  theme(text = element_text(size=12)) +
  theme_bw()
```


```{r summary_N2O_vs_NO3cat_surftemp, echo=FALSE, fig.align='center', fig.height=5, fig.width=8, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(outlier.shape = NA, color = "black", alpha = 0.7) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(surftemp, 6))) +
  theme_bw()
```


```{r summary_N2O_vs_NO3cat_logarea, echo=FALSE, fig.align='center', fig.height=5, fig.width=8, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(outlier.shape = NA, color = "black", alpha = 0.7) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(log_area, 6))) +
  theme_bw()
```

Below is a plot of log(dissolved N2O) vs. log(NO3) by ecoregion, which suggested that the NO3 effect on dissolved N2O may have varied by ecoregion.

```{r summary_N2O_vs_NO3_ecoregion, echo=FALSE, fig.align='center', fig.height=6, fig.width=8, message=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  geom_vline(xintercept = -7.5, linetype = "dashed") +
  geom_vline(xintercept = -5.5) +
  geom_vline(xintercept = -3.5) +
  geom_vline(xintercept = -1.5) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ WSA9) +
  theme_bw()
```

Below is the same plot as above but for the ordered categorical version of NO3.

```{r summary_N2O_vs_NO3cat_ecoregion, echo=FALSE, fig.align='center', fig.height=6, fig.width=8, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(aes(x = no3_cat, y = log(n2o)), 
               outlier.shape = NA, 
               color = "black", 
               alpha = 0.7) + 
  facet_wrap(~ WSA9) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

A plot below shows the relationships between dissolved N2O and log(NO3) by state, but within just the Temperate Plains (TPL) ecoregion. Within states, the number of observations were relatively small, but the trends were perhaps more linear.

```{r summary_N2O_vs_NO3_wsa9state3, echo=FALSE, fig.align='center', fig.height=4, fig.width=8, message=FALSE}
df_model %>%
  filter(WSA9 == "TPL") %>%
  ggplot(aes(x = log(no3), y = log(n2o), group = state, color = state)) +
  geom_point(show.legend = F) +
  geom_smooth(method = "lm", span = 2, alpha = 0.1) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

# Model fitting
The first regression model was constructed to estimate the joint distribution of log-transformed dissolved and equilibrium N2O conditional only on the the survey design factors. Each log-transformed observation, $i \in 1,..,N=984$, for each response, $p \in 1:P=2$, was assumed to be drawn from a multivariate normal distribution with the parameters $\nu$ and $\Sigma$, where $\nu$ is the multivariate mean estimated conditional on the design effects and $\Sigma$ is a covariance matrix containing the observation-level variances and residual correlation:
$$Y \sim MVN(\nu, \Sigma)$$

The multivariate mean is a vector of location parameters, $\nu:[\mu_{p=1}, \mu_{p=2}]$, for each response. Each location parameter was further defined by a linear combination of parameters where, for each response $p$ and observation $i$:

$$\mu_{pi} = \alpha_{0(pi)} + \alpha_{1(pij)} + \alpha_{2(pijk)} + \alpha_{3(pijkl)} \\
\alpha_1 \sim MVN(0, \Lambda_1) \\
\alpha_2 \sim MVN(0, \Lambda_2) \\
\alpha_3 \sim MVN(0, \Lambda_3)$$

The linear combination included a fixed global intercept, $a_0$, estimated directly from the data, and three separate, latent group-level effects matrices, $\alpha_1, \alpha_2, \alpha_3$. The group effects were assumed to be multivariate normal and were centered on zero in the two-dimensional multivariate space. The spread of the effects around zero were determined by a covariance matrix, $\Lambda_1, \Lambda_2, \text{or } \Lambda_3$, which were estimated directly from the data. The covariance terms were further defined where:

$$\Lambda = \begin{pmatrix} 1 & \tau^2_{p=1} \\ \tau^2_{p=2} & 1 \end{pmatrix} \chi \begin{pmatrix} 1 & \tau^2_{p=1} \\ \tau^2_{p=2} & 1 \end{pmatrix}$$

The $\tau$ parameters captured the group-level standard deviations, which constrain the spread of group-level effects for each response, and $\chi$ was the group-level residual correlation matrix:

$$\chi = \begin{pmatrix} 1 & \varrho \\ \varrho & 1 \end{pmatrix}$$

wherein $\varrho$ captured the group-level residual correlation between effects.

The explicit indexing in the notation above conveys the relationship between the parameters and each observation, $i$, and emphasizes the nested structure of the observations within the group effects. Specifically, each observation, $i$, was nested in a lake size category, $l$, which was nested in a state, $k$, and ecoregion, $j$. The parameter $\alpha_1$, therefore, accounted for ecoregion-scale group effects or deviations from the global mean; $\alpha_2$ accounted for state-level group effects nested in ecoregions; and $\alpha_3$ accounted for lake size group effects within states and ecoregions.  

Finally, the observation-level covariance term, $\Sigma$, was parameterized as:
$$\Sigma = \begin{pmatrix} 1 & \sigma^2_{p=1} \\ \sigma^2_{p=2} & 1 \end{pmatrix} \Omega \begin{pmatrix} 1 & \sigma^2_{p=1} \\ \sigma^2_{p=2} & 1 \end{pmatrix}$$

wherein the $\sigma$ parameters were the observation-level standard deviations for each response and $\Omega$ was the observation-level residual correlation matrix:
$$\Omega = \begin{pmatrix} 1 & \rho \\ \rho & 1 \end{pmatrix}$$
wherein $\rho$ captured the residual correlation between responses.

For model fitting, priors were needed for all parameters conditioned directly on the data, which included the global intercept, the scale parameters, and the correlation matrices. A normal or Gaussian prior, $N(\mu = 2, \sigma = 1)$ centered near the (log-scale) data means, was used for the global mean parameter for each response. This prior was considered minimally informative as it placed most (~80%) of the prior mass over values between approximately 2 and 27 ng/L for median N2O or N2O equilibrium concentration and included support in the tails for values approaching 0 ng/L on the lower end and 80 ng/L on the high end. We placed $Exp(2)$ priors over all scale parameters, which placed most of the support between values very close to 0 and values near 1 (central 80% density interval from approximately 0.005 to 1.15). Finally, for the correlation matrices, an $LKJ(\eta =2)$ prior was used, which, for a 2-dimensional response, placed most support for correlations between approximately -0.9 and 0.9. This prior seemed reasonable as there were no clear causal mechanisms to ensure a very strong correlation between the N2O measures. Any potential residual dependence was expected to be indirect due to, for example, a common correlate (e.g., elevation, temperature). For more information on prior choice recommendations in Stan, see: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations

The $\textbf{brms}$ package [@Burkner_2017] for $\textbf{R}$ [@R_Core_Team_2021] was used to fit all of the models in a fully Bayesian setting. The formula syntax of the $\textbf{brms}$ package is similar to the syntax used in the $\textbf{lme4}$ package that is widely used to fit mixed effects models in frequentist settings. In either package, the linear predictor for $\mu$ described above could be expressed as:

$$\sim 1 + (1|WSA9) + (1|WSA9:state) + (1|WSA9:state:size)$$

In the $\textbf{brms}$ package, there is additional functionality and formula syntax for multivariate responses and for allowing the varying intercepts in a multivariate model to be correlated, e.g.,:

$$
\begin{aligned} 
  N_2O_{diss} \sim 1 + (1|a|WSA9) + (1|b|WSA9:state) + (1|c|WSA9:state:size) \\
  N_2O_{equi} \sim 1 + (1|a|WSA9) + (1|b|WSA9:state) + (1|c|WSA9:state:size) 
\end{aligned}
$$

The above formula syntax would indicate that the linear predictor for both responses in the multivariate model have the same group-level varying effects, and that those effects may be correlated between responses. 

For the remainder of this document, only this simplified syntax is presented to describe the model structure. For more information on $\textbf{brms}$ functionality and syntax with multivariate response models, the package vignette may be helpful, and can be found at: https://cran.r-project.org/web/packages/brms/vignettes/brms_multivariate.html.

## Model 1

The first model fit.

```{r n2o_mod_mv_1, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ 1 + 
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ 1 + 
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) +
               (1 | c | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"), # centered near data mean
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(exponential(2), class = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), # centered near data mean
  prior(exponential(2), class = "sd", resp = "logn2oeq"),
  prior(exponential(2), class = "sigma", resp = "logn2oeq"),
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod1 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model,
                prior = priors,
                control = list(adapt_delta = 0.99, max_treedepth = 14),
                #sample_prior = "only",
                save_pars = save_pars(all = TRUE),
                seed = 145,
                chains=4, 
                iter=5000, 
                cores=4)

save(n2o_mod1, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod1.rda")
```

### Summarize fit

The summaries of the estimated parameters and key HMC convergence diagnostics for the fitted model are printed below. There were no obvious issues with the HMC sampling. All $\hat{R}$ values were less than 1.01 and effective sample size ($ESS$) calculations suggested that the posterior contained a sufficient number of effective samples for conducting inference.

```{r print_mod1, echo=FALSE}
print(n2o_mod1, prior = T)
```

In the summary above, the estimated standard deviations for the varying group effects on the mean behavior of the dissolved N2O response suggested fairly low, but non-zero variability across each of the three levels. The standard deviations estimated for the same varying effects for equilibrium N2O were also relatively small. Finally, note the relatively small, but positive residual correlation between the two N2O responses. 

Before investing too much into inferences from this model, however, the model fit was evaluated below using a series of graphical posterior predictive checks [PPC, @Gelman_etal_2014; @Gelman_etal_2020, Ch. 11].

### Model checks

#### Dissolved N2O

Below are a series of panels illustrating graphical PPCs for the dissolved N2O component of the multivariate model. The top left panel compares a density plot of the observed data (black line) to density estimates drawn for 200 samples from the posterior predictive distribution (PPD; blue lines) of the fitted model. The top right panel compares the cumulative density distributions in the same manner. The left middle panel compares means _vs._ standard deviations for 1000 draws from the PPD (blue dots) to the sample mean _vs._ standard deviation (black dot). The right middle panel compares skewness _vs._ kurtosis for 1000 draws from the PPD to the skewness _vs._ kurtosis estimates for the observed data. The bottom left panel compares max _vs._ min values for 1000 draws from the PPD to the max _vs._ min values of the sample data. Finally, the bottom right panel shows the observed _vs._ average predicted values for each observation in the sample. The average predicted values were calculated as the mean prediction for each observation in the PPD based on 1000 draws.

```{r ppc_n2o1, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200, 
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "scatter_avg",
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

The general takeaway from the PPCs above was that the model replicated the central tendency of the observed data fairly well, but failed to sufficiently replicate other important aspects of the distribution, such as skewness and kurtosis. The observed _vs._ average predictions scatterplot also suggested substantial heteroscedasticity in the errors. 

The same checks were run below, but for the test set of 95 held-out, second-visit data points. The patterns in misfit were similar to the patterns indicated in the PPCs with the training data above.

```{r ppc_n2o1_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200, 
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "scatter_avg",
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O
Below are PPCs for the equilibrium N2O component of the model. As with the dissolved N2O PPCs, the model seemed to do an OK job at replicating the central tendency, but performed less well at replicating other important aspects of the overall distribution. 

```{r ppc_n2oeq1, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200, 
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

Below are the same PPCs for equilibrium N2O in the re-visit sites.

```{r ppc_n2oeq1_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1,
         newdata = df_test,
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200, 
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate
The graphical check below compared bivariate density contours estimated from the observed data (black lines) to density contours estimated for each of 20 draws from the PPD. The model appeared to do a good job of replicating the bivariate mean, but was poor at representing the overall joint distribution.

```{r ppc_biv1, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 20) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o), y = log(n2o_eq))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

The same bivariate check is shown below for the re-visit data.

```{r ppc_biv1_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 20) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o), y = log(n2o_eq))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation
The graphical PPCs below were aimed at evaluating how well the multivariate model did at representing the observed saturation ratio: 

$$\dfrac{N_2O_{diss}} {N_2O_{equi}}$$

This quantity was estimated as a derived variable by dividing the dissolved N2O PPD by the equilibrium N2O PPD. The proportion of under-saturated lakes in the sample was estimated by summing the number of lakes from each posterior predictive draw wherein the ratio was < 1 and dividing that number by the total number of lakes in the sample, which was 984.
Overall, these checks indicated that properly representing the tails of the dissolved N2O and N2O-eq observations would likely be necessary in order to better replicate the observed saturation metrics. The observed proportion of under-saturated lakes was underestimated by more than 10 percentage points, on average.

The top left panel, below, is a density plot of the observed saturation ratio (black line) compared to an estimate using 50 draws from the derived PPD (blue lines). The top right panel shows the observed proportion of under-saturated lakes compared to a model estimate based on 1000 draws from the PPD. The left middle panel shows the mean _vs._ standard deviation of the saturation ratio for the observed data compared to the same estimates for 500 draws from the PPD. The right middle panel shows the max _vs._ min for the sample compared to 500 draws from the PPD. Finally, the bottom left panel shows the observed _vs._ average predicted saturation ratio for all 984 lakes sampled in the dataset.

```{r ppc_sat1, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 984) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The same PPCs are shown below for the revisit data. These checks indicated that the model did a similarly underwhelming job of replicating the re-visit data.

```{r ppc_sat1_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 95) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/95)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

Below, the Bayesian $R^2$ values are reported for each response in the model.

```{r r2_1, echo=FALSE, message=FALSE, warning=FALSE, cache = TRUE}
round(bayes_R2(n2o_mod1, resp = "logn2o", cores = 1), 3)
round(bayes_R2(n2o_mod1, resp = "logn2oeq", cores = 1), 3)
```

The $R^2$ were also estimated for the re-visit data.

```{r r2_1_test, echo=FALSE, message=FALSE, warning=FALSE, cache = TRUE}
round(bayes_R2(n2o_mod1, resp = "logn2o", newdata = df_test, cores = 1), 3)
round(bayes_R2(n2o_mod1, resp = "logn2oeq", newdata = df_test, cores = 1), 3)
```

## Model 2

In an attempt to better fit the observed data, the next model included a distributional sub-model that allowed for heterogeneous variances. The distributional terms for both N2O responses were each fit as a function of the survey design structure. The same structure as for the models for the submodels for the mean component before.

```{r n2o_mod_2, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ 1 +
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ 1 +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod2 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 84512,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod2, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod2.rda")
```

### Summarize fit

The summaries of the estimated parameters and key HMC convergence diagnostics for the fitted model are printed below.

```{r print_mod2, echo=FALSE}
print(n2o_mod2, prior = T)
```

### Model checks

Below the same PPCs were performed as with the initial model (see above for more details on each panel). Though the checks below suggested some improvement in replicating the tails of the observed data, the overall fit again suggested room for improvement.

##### Dissolved N2O

```{r ppc_n2o2, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlim(-5, 5) +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200, 
         cores = 1) + 
  theme_tidybayes() +
  xlim(-5, 5) +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "scatter_avg", 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The checks below suggested that this model offered little no improvement upon the initial model for equilibrium N2O. 

```{r ppc_n2oeq2, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         ndraws = 1000,
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000,
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

This check perhaps suggested an improvement with regard to replicating the joint density. However, the predictions were still clearly over-dispersed relative to the observations.

```{r ppc_biv2, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

The PPCs for the saturation metrics below indicated that including the distributional models was perhaps an improvement on the initial model in some aspects; in particular, the bias in the predicted proportion of under-saturated lakes was substantially decreased. However, there appeared to still be issues in replicating the tails as well as issues with central tendency.

```{r ppc_sat2, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 984) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

Relative to model 1, there was a substantial decrease in the $R^2$ estimate for the dissolved N2O component of this model. The estimate for the equilibrium N2O-eq component was similar to model 1. 

```{r r2_2, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod2, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod2, resp = "logn2oeq", cores = 1), 3)
```

## Model 3

In the next model, the categorical version of the NO3 covariate and a surface temperature covariate were included to try to improve the fit. The ordinal NO3 variable was used as a monotonic, ordinal effect and only in the dissolved N2O component of the model. For the equlibrium N2O component, surface temperature and log-transformed elevation were used, along with their interaction. The model also retained the same distributional specifications included in model 2 above.

```{r n2o_mod_3, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ mo(no3_cat) +
               surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(normal(0, 1), class = "b", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(normal(0, 1), class = "b", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"), 
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod3 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 98456,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod3, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod3.rda")
```

### Summarize fit

The fitted parameters and MCMC diagnostics are below.

```{r print_mod3, echo=FALSE}
print(n2o_mod3, prior = T)
```

### Model checks

#### Dissolved N2O

The PPCs below indicated a better fit compared to the previous models. The central tendency and tail behavior looked to be reasonably replicated by comparison. However, the observed _vs._ predicted plot suggested that larger N2O observations were likely being systematically underestimated.

```{r ppc_full_checks_mod_n2o3, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlim(0, 5) +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlim(0, 5) +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         ndraws = 1000,
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),  
         ndraws = 1000,
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"),  
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "scatter_avg",  
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The PPCs below indicated that this model appeared to be an improvement for equilibrium N2O as well. However, some checks (e.g., skewness) suggested some room for additional improvement.

```{r ppc_full_checks_mod_n2oeq3, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "dens_overlay", 
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "ecdf_overlay", 
         ndraws = 200,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),  
         ndraws = 1000,
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000, 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"),  
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "scatter_avg",  
         ndraws = 1000,
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

The check for the joint distribution below also suggested an improvement upon the previous models.

```{r ppc_bv_check_mod_n2o3, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

This model looked to be an improvement with regard to the PPCs for the saturation metrics. However, the proportion of under-saturated lakes remained biased low and other checks indicated that further improvements would be ideal.

```{r ppc_sat_check_mod_n2o3, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 984) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

The $R^2$ estimates for this model are below and suggested substantial improvements over the previous models.

```{r r2_mod_n2o3, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod3, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod3, resp = "logn2oeq", cores = 1), 3)
```

### Covariate effects

Below are plots illustrating the modeled effects of covariates on both N2O and equilibrium N2O.

#### Dissolved N2O

The conditional effects plots below for dissolved N2O illustrated a positive, monotonic, and non-linear relationship with NO3; and a negative, linear relationship with surface temperature.

```{r conditional_effects_mod_n2o3, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod3, 
                          resp = "logn2o", 
                          effects = c("no3_cat"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod3, 
                          resp = "logn2o", 
                          effects = c("surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
          plot(p2, plot = F)[[1]],
          ncol = 2)

rm(p1, p2)

annotate_figure(plt, top = text_grob("Conditional effects: N2O", 
               color = "black", face = "bold", size = 14))
```

#### Equilibrium N2O

The modeled effects for the equilibrium N2O component illustrated a negative relationship with both predictors and an interaction such that the surface temperature effect became slightly steeper at lower elevations.

```{r conditional_effects_mod_n2oeq3, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod3, 
                          resp = "logn2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod3, 
                          resp = "logn2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob("Conditional effects: Equilibrium N2O", 
               color = "black", face = "bold", size = 14))
```

## Model 4

In the next model, covariate terms were also included in the $\sigma$ components of both models in order to try to better capture remaining heterogeneity in the variances of both N2O and N2O-eq.

```{r n2o_mod_mv_4, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ mo(no3_cat) +
               surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ mo(no3_cat) +
               surftemp +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(normal(0, 1), class = "b", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(normal(0, 1), class = "b", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"), 
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod4 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 15851,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod4, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod4.rda")
```

### Summarize fit

Below is a summary of the fitted parameters along with some convergence diagnostics.

```{r print_mod4, echo=FALSE}
print(n2o_mod4, prior = T, digits = 3)
```

### Model checks

The same PPCs were employed for this model as above.

#### Dissolved N2O

This model appeared to be a moderate improvement on the previous models.

```{r ppc_full_checks_mod_n2o4, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2o",
         type = "dens_overlay",
         nsamples = 40,
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2o",
         type = "ecdf_overlay",
         nsamples = 40, 
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         resp = "logn2o",
         type = "scatter_avg", 
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

This component of the model also seemed to be an improvement over model 3, with better representation in the tails as indicated in the skewness _vs._ kurtosis PPC. 

```{r ppc_full_checks_mod_n2oeq4, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "dens_overlay",
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "ecdf_overlay",
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "scatter_avg", 
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

Again, an improvement over the previous model with a tighter fit of the PPC to the observed bivariate density.

```{r ppc_bv_check_mod_n2o4, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

This check also suggested an improvement over the previous models, with better tail behavior and less bias in the proportion under-saturated measure.

```{r ppc_sat_check_mod_n2o4, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 984) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

The Bayesian $R^2$ estimates below indicated an improvement from the previous models.

```{r r2_mod_n2o4, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod4, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod4, resp = "logn2oeq", cores = 1), 3)
```

### Covariate effects

#### Dissolved N2O

The conditional effects plots for the covariate effects on dissolved N2O remained similar to the previous model.

```{r conditional_effects_mod_n2o4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o", 
                          effects = c("no3_cat"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o", 
                          effects = c("surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
          plot(p2, plot = F)[[1]],
          ncol = 2)

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": N2O")), 
               color = "black", face = "bold", size = 14))
```

Below are estimates of the conditional effects of the covariates on $\sigma$ for N2O. These plots suggested a large effect of NO3 on the variance of N2O, but little to no effect of surface temperature.

```{r conditional_effects_sigma_n2o4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("no3_cat"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, 
                top = text_grob(expression(paste("Covariate effects on ", sigma, ": N2O")),
                                color = "black",
                                face = "bold",
                                size = 14))
```

#### Equilibrium N2O

The covariate effects on equilibrium N2O remained largely the same as for the previous model.

```{r conditional_effects_mod_n2oeq4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)
plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

The covariate effects on $\sigma$ for N2O-eq suggested a negative effect of surface temperature and litte to no effect of elevation.

```{r conditional_effects_sigma_n2oeq4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("surftemp"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("log_elev"), 
                          plot = F)
plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", sigma, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

## Model 5

In the next model, additional complexity is added to the dissolved N2O component by including a covariate for continuous lake surface area (log scale) as well as interactions between NO3 and log(surface area) and surface temperature. Although, some aspect of lake size was likely captured by the categorical size factor from the survey in the models above, the largest category is very coarse and includes all lakes >50 hecatares, which is an extremely wide distribution of sizes from 50 to over 300,000 hectares at max. Including the continuous size covariate at the observation level in this manner was expected to do a better job of resolving any trends with size. Colinearity between the grouped and observation-level measures were not a major, concern, since the observation-level measure would account for any variation first. However, we did later check for any common violations of the Gauss-Markov assumptions, by looking at potential correlations between the model errors and covariates [not shown; @Bafumi_Gelman_2007].

```{r n2o_mod_mv_5, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ mo(no3_cat) +
               log_area +
               surftemp + 
               mo(no3_cat):log_area +
               mo(no3_cat):surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ log_area +
               mo(no3_cat) +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(normal(0, 1), class = "b", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(normal(0, 1), class = "b", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"), 
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod5 <- brm(bf_n2o + 
                  bf_n2oeq +
                  set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 54741,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod5, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod5.rda")
```

### Summarize fit

Below is a summary of the fitted parameters along with MCMC convergence diagnostics.

```{r print_mod5, echo=FALSE}
print(n2o_mod5, prior = T, digits = 3)
```

### Model checks

Again, the same PPCs as above were performed for this model.

#### Dissolved N2O

This PPCs for dissolved N2O looked similar to the previous model.

```{r ppc_full_checks_mod_n2o5, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2o",
         type = "dens_overlay",
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2o",
         type = "ecdf_overlay",
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "scatter_avg", 
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

Again, the PPCs for this model were similar to the previous model, which was unsurprising given that it was the same model for N2O-eq.

```{r ppc_full_checks_mod_n2oeq5, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "dens_overlay",
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "ecdf_overlay",
         cores = 1) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "scatter_avg", 
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

This PPC was also similar to the previous model.

```{r ppc_bv_check_mod_n2o5, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

This check was also similar to the prevoius model, with perhaps slightly less bias in the proportion unsaturated estimates. There was also a potentially concerning extreme prediction in the observed _vs_ predicted PPC.

```{r ppc_sat_check_mod_n2o5, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 984) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

```{r r2_mod_n2o5, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod5, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod5, resp = "logn2oeq", cores = 1), 3)
```

### Covariate effects

#### Dissolved N2O

The conditional effects plots suggested a similar effect of NO3, but interesting interactions between NO3 and lake area and NO3 and surface temperature. For lake area, the effect was estimated to be larger and more negative at the highest levels of NO3; and slightly negative at the lowest level of NO3. For surface temperature, the effect was estimated to be largest and positive at the highest level of NO3; and negative at the lowest level of NO3.

```{r conditional_effects_mod_n2o5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o", 
                          effects = c("no3_cat"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o", 
                          effects = c("log_area:no3_cat"), 
                          plot = F)
p3 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o", 
                          effects = c("surftemp:no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
                 plot(p2, plot = F)[[1]],
                 plot(p3, plot = F)[[1]])

rm(p1, p2, p3)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": N2O")), 
               color = "black", face = "bold", size = 14))
```

The estimated covariate effects on $\sigma$ suggested a negative relationship with log(area) and a positive relationship, again, with NO3.

```{r conditional_effects_sigma_n2o5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("log_area"),
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, 
                top = text_grob(expression(paste("Covariate effects on ", sigma, ": N2O")),
                                color = "black",
                                face = "bold",
                                size = 14))
```

#### Equilibrium N2O

The estimated covariate effects on equilibrium N2O remained largely the same as estimated in the previous model.

```{r conditional_effects_mod_n2oeq5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```


```{r conditional_effects_sigma_n2oeq5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("surftemp"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("log_elev"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", sigma, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

## A Final Model

As demonstrated above, models excluding the NO3 covariate consistently resulted in poorer fits to to the observed dissolved N2O data and potentially biased estimates of the saturation ratio. Including surface temperature and elevation in the equilibrium N2O part of the model also resulted in substantially improved replication of key aspects of the observed data. Added flexibility in the distributional terms for both dissolved and equilibrium N2O also led to improvements. 

To make inferences to the population of interest from a model including these covariates, however, the covariates needed to be (1) fully observed across that population or (2) their missingness needed to be modeled. For the lake area and elevation covariates, data _was_ available for all lakes from previously compiled geospatial databases. However, neither surface temperature or NO3 were observed for lakes outside of the sample. That is, they were partially observed with respect to the target population. Therefore, a more complex model was constructed below that included surface temperature and NO3 as additional responses conditioned on the survey design variables and fully observed covariates. This approach to inference for N2O was similar to a Bayesian structural equation modeling approach [@Merkle_etal_2021; @Merkle_Rosseel_2018]. The logical dependence structure could be characterized as:

$$\begin{aligned} 
{p( \boldsymbol{N_2O_{diss}}} &| Survey, Area, {\boldsymbol{NO_3}}, {\boldsymbol{Temp}}) \\ 
{p( \boldsymbol{N_2O_{equil}}} &| Survey, Elev, {\boldsymbol{Temp}})\\
{p( \boldsymbol{NO_3}} &| Survey, Area, {\boldsymbol{Temp}}) \\ 
{p( \boldsymbol{Temp}} &| Survey, Lat, Elev, Day)
\end{aligned}$$

Variables in bold text above were treated as partially observed with respect to the population of interest (i.e., observed only in the sample), whereas variables not in bold were considered fully observed. The partially observed variables, being dissolved and equilibrium N2O, NO3, and surface temperature, were each modeled conditional on the survey design variables and other partially and/or fully observed covariates. This piece-wise approach to predicting N2O required a more complex set of post-processing steps compared to a typical MRP analysis. In order to propagate uncertainty through the dependency structure and make inferences to the POI below, the fitted final model was used to first predict surface temperature in the target population, since it depended only on the fully observed covariates. That predictive distribution was then used alongside the relevant fully observed covariates to predict NO3 in the target population. Finally, the predictive distributions for temperature and NO3 were used to predict the N2O responses. These steps were carried out in the "Predict to population" section to follow.

In the final model below, the sub-model for surface temperature assumed a Gamma distributed error distribution and the linear predictor included the survey design variables, latitude, elevation, and Julian date. The shape parameter was also modeled as a function of latitude to address increasing response variance along the latitudinal gradient. The NO3 sub-model was a cumulative logit model and the linear predictor included all of the survey factors as well as surface temperature and lake area. 

The dissolved and equilibrium N2O responses were each modeled with Gamma distributed errors, but with the same covariate structure as in model 5. The same structure was also employed for the shape terms in these responses, corresponding to the $\sigma$ terms in the previous models. Though not shown in this document, the Gamma error structure appeared to result in slightly better performance in the predictive checks compared to the Gaussian errors in previous models. This was primarily apparent in the saturation ratio checks, which may have been more sensitive to model performance in the tails of the N2O responses. Others have also indicated that the Gamma error distribution can work well for dissolved N2O data [@Webb_etal_2019].

Note that there was no observation-level residual correlation term for this model, since the residuals are undefined for the Gamma and cumulative logit models. Dropping the observation-level residual correlation term was deemed a reasonable compromise that enabled the inclusion of NO3 as a covariate on dissolved N2O. The random intercepts, however, still allowed for potential correlations between the four responses at the group levels. 

```{r n2o_mod_mv_6, eval=FALSE, include=TRUE}
bf_n2o <- bf(n2o ~ mo(no3_cat) +
               log_area +
               surftemp + 
               mo(no3_cat):log_area +
               mo(no3_cat):surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             shape ~ log_area +
               mo(no3_cat) +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = Gamma(link = "log"))

bf_n2oeq <- bf(n2o_eq ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             shape ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = Gamma(link = "log"))

bf_temp <- bf(surftemp ~ lat +
                s(log_elev) +
                s(jdate) +
                (1 | a | WSA9) + 
                (1 | b | WSA9:state) +
                (1 | c | WSA9:state:size_cat),
              shape ~ lat,
              family = Gamma(link = "log"))

bf_no3 <- bf(no3_cat ~ surftemp +
               log_area +
               (1 | a | WSA9) +
               (1 | b | WSA9:state) +
               (1 | c | WSA9:state:size_cat),
             family = cumulative(link = "logit", threshold="flexible"))

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "n2o"),
  prior(normal(0, 1), class = "b", resp = "n2o"),
  prior(exponential(2), class = "sd", resp = "n2o"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "n2o"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "n2o"),
  prior(exponential(2), class = "sd", dpar = "shape", resp = "n2o"),
  
  prior(normal(2, 1), class = "Intercept", resp = "n2oeq"), 
  prior(normal(0, 1), class = "b", resp = "n2oeq"),  
  prior(exponential(2), class = "sd", resp = "n2oeq"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "n2oeq"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "n2oeq"),
  prior(exponential(2), class = "sd", dpar = "shape", resp = "n2oeq"),
  
  prior(normal(3, 1), class = "Intercept", resp = "surftemp"), 
  prior(normal(0, 1), class = "b", resp = "surftemp"), 
  prior(exponential(0.5), class = "sds", resp = "surftemp"),
  prior(exponential(2), class = "sd", resp = "surftemp"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "surftemp"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "surftemp"),
  
  prior(normal(0, 3), class = "Intercept", resp = "no3cat"),
  prior(normal(0, 1), class = "b", resp = "no3cat"),
  prior(exponential(1), class = "sd", resp = "no3cat"),
  
  prior(lkj(2), class = "cor")
  )

n2o_mod6 <- brm(bf_n2o + 
                  bf_n2oeq + 
                  bf_temp + 
                  bf_no3 + 
                  set_rescor(rescor = FALSE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 14),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 85132,#14548,
  #init = my_inits,
  init_r = 0.5,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod6, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod6.rda")
```

### Summarize fit
Below is a summary of the fitted parameters and MCMC diagnostics. 
```{r print_mod6, echo=FALSE}
print(n2o_mod6, digits = 3, prior = T)
```

### Model checks

Below, the same PPCs for dissolved and equilibrium N2O were used as before.

#### Dissolved N2O

The PPCs for dissolved N2O were similar to those for models 4 and 5 above.

```{r ppc_full_checks_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod6, 
         resp = "n2o",
         type = "dens_overlay",
         nsamples = 40,
         cores = 1) + 
  theme_tidybayes() +
  scale_x_continuous(trans = "log") +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod6, 
         resp = "n2o",
         type = "ecdf_overlay",
         nsamples = 40, 
         cores = 1) + 
  theme_tidybayes() +
  scale_x_continuous(trans = "log") +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod6, 
         resp = "n2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         resp = "n2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         resp = "n2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         resp = "n2o",
         type = "scatter_avg", 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The PPCs for eqilibrium N2O were also similar to the same checks in models 4 and 5.

```{r ppc_full_checks_mod_n2oeq6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod6, 
         resp = "n2oeq",
         type = "dens_overlay",
         nsamples = 40,
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod6, 
         resp = "n2oeq",
         type = "ecdf_overlay",
         nsamples = 40, 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod6, 
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         resp = "n2oeq",
         type = "scatter_avg", 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

This final model provided a reasonable representation of the bivariate relationship between the two N2O responses.

```{r ppc_bv_check_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod6,
                      resp = c("n2o","n2oeq"),
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = log(n2o), 
                      y = log(n2oeq), 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

The saturation ratio PPCs below suggested similar behavior as with models 4 and 5 above, but with perhaps slightly less bias in the predictions for the proportion of undersaturated waterbodies and fewer extreme predictions for the means and standard deviations. The observed _vs._ predicted PPC also appears to have a better behaved variance and no extreme predictions, compared to models 4 and 5.

```{r ppc_sat_check_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"),
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(n2o < n2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 984) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The plot below shows the same PPC, but for the second-vist data.

```{r ppc_sat_check_testdata_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"),
                      ndraws = 50) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(n2o < n2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / 95) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/984)) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 500) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

Below are estimates for the Bayesian $R^2$, which were largely similar for the N2O responses as with models 4 and 5 above. The $R^2$ for the surface temperature response also suggested a good fit.

```{r r2_mod_n2o6, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod6, resp = "n2o"), 3) 
round(bayes_R2(n2o_mod6, resp = "n2oeq"), 3)
round(bayes_R2(n2o_mod6, resp = "surftemp"), 3)
```

Below are the $R^2$ estimates for the second-visit data. That these estimates were similar to those for the data used to fit the model was encouraging and suggested that the model may perform reasonably well out-of-sample.

```{r r2_test_mod_n2o6, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod6, resp = "n2o", newdata = df_test), 3) 
round(bayes_R2(n2o_mod6, resp = "n2oeq", newdata = df_test), 3)
round(bayes_R2(n2o_mod6, resp = "surftemp", newdata = df_test), 3)
```

### Covariate effects

#### Dissolved N2O

The conditional effects plot for the covariate effects on dissolved N2O suggested a similar effect of NO3 as in previous models, but with interesting potential interactions between NO3 and lake area and NO3 and surface temperature. The lake area effect was estimated to be larger and more negative at the highest levels of NO3 and slightly negative at the lowest level of NO3. The surface temperature effect was estimated to be largest and positive at the highest level of NO3 and negative at the lowest level of NO3.

```{r conditional_effects_mod_n2oF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("no3_cat:log_area"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("log_area:no3_cat"), 
                          plot = F)

p3 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("no3_cat:surftemp"), 
                          plot = F)

p4 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("surftemp:no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
                 plot(p2, plot = F)[[1]],
                 plot(p3, plot = F)[[1]],
                 plot(p4, plot = F)[[1]])

rm(p1, p2, p3, p4)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": N2O")), 
               color = "black", face = "bold", size = 14))
```

The estimated covariate effects on $\sigma$ for dissolved N2O suggested a negative relationship with log(area) and a positive relationship with NO3.

```{r conditional_effects_sigma_n2oF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2o",
                          dpar = "shape",
                          effects = c("log_area"),
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2o",
                          dpar = "shape",
                          effects = c("no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, 
                top = text_grob(expression(paste("Covariate effects on ", shape, ": N2O")),
                                color = "black",
                                face = "bold",
                                size = 14))
```

#### Equilibrium N2O

The estimated covariate effects on equilibrium N2O remained largely the same as estimated in the previous model.

```{r conditional_effects_mod_n2oeqF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```


```{r conditional_effects_sigma_n2oeqF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq",
                          dpar = "shape",
                          effects = c("surftemp"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq",
                          dpar = "shape",
                          effects = c("log_elev"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", shape, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```


#### Saturation ratio

Below are the estimated conditional effects of the covariates on means for both n2o responses as well as the implied effects on the mean saturation ratio. 

```{r conditional_effects_mod_n2osat_temp_F, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
effect_no3_surftemp <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               surftemp = round(quantile(df_model$surftemp, 
                                                   probs = seq(0.10, 0.90, 0.2)), 0),
                               log_area = mean(df_model$log_area),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         surftemp = factor(surftemp))

effect_surftemp_no3 <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               surftemp = seq(range(df_model$surftemp)[1],
                                              range(df_model$surftemp)[2],
                                              length.out = 101),
                               log_area = mean(df_model$log_area),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         temp = surftemp)

plt_n2oeq_surftemp <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = n2oeq_pred),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Equilibrium N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 20), breaks = seq(0, 20, 5)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Greys", guide = "none")


plt_n2o_surftemp_no3 <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Dissolved N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(axis.text.x = element_blank(),
        legend.position = "none")

plt_n2o_no3_surftemp <-
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab("") +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

plt_sat_no3_surftemp <-
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = sat_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab(expression(paste("NO"[3], " category"))) +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  theme(legend.position = "none",
        axis.text.y = element_blank())

plt_sat_surftemp_no3 <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = sat_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("Surface temperature (\u00B0C)") +
  ylab("Saturation ratio") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_fill_brewer(palette = "Greys", guide = "none") +
  theme(legend.position = "none")

legend1 <- effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  theme_void() +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(legend.position = c(0.5, 0.1),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = expression(paste("NO"[3], " category"))) +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 0.5))

legend1 <- get_legend(legend1)

legend2 <- 
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  theme_void() +
  theme(legend.position = c(0.5, 0.5),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = "Surface temperature (\u00B0C)") +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 1))

legend2 <- get_legend(legend2)

legendPlot <- ggarrange(legend1, legend2, ncol = 1)

plt_surftemp_effects <- ggarrange(plt_n2oeq_surftemp,
                                  legendPlot,
                                  plt_n2o_surftemp_no3,
                                  plt_n2o_no3_surftemp,
                                  plt_sat_surftemp_no3,
                                  plt_sat_no3_surftemp,
                             ncol = 2,
                             nrow = 3,
                             widths = c(1, 1, 1, 1, 1, 1),
                             heights = c(1, 1, 1, 1, 1, 1),
                             labels = c("A", "Legend", "B", "C", "D", "E"),
                             hjust = c(-6, -1, -6, -6, -6, -6),
                             vjust = c(2, 2, 2, 2, 2, 2)
                             )

plt_surftemp_effects <- plt_surftemp_effects %>%
  annotate_figure(plt_surftemp_effects,
                  left = text_grob("Posterior mean", 
                                   size = 18, 
                                   rot = 90)
                  )

# ggsave only works in R console (i.e., copy + paste to save)
ggsave(filename = "cond_effect_surftemp_no3.tif",
       plot = plt_surftemp_effects,
       device = "tiff",
       width = 180 / 25.4,
       height = 210 / 25.4,
       units = "in")
```

```{r plot_surftemp_effects, echo=FALSE, fig.align='center', fig.asp=1.166667, fig.width=8}
plt_surftemp_effects
```

```{r conditional_effects_mod_n2osat_area_F, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
effect_no3_area <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               log_area = round(quantile(df_model$log_area, 
                                                   probs = seq(0.10, 0.90, 0.2)), 0),
                               surftemp = mean(df_model$surftemp),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         log_area = factor(log_area))

effect_area_no3 <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               log_area = seq(range(df_model$log_area)[1],
                                              range(df_model$log_area)[2],
                                              length.out = 101),
                               surftemp = mean(df_model$surftemp),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         log_area = log_area)

plt_n2oeq_area <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = n2oeq_pred),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Equilibrium N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 20), breaks = seq(0, 20, 5)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Greys", guide = "none")


plt_n2o_area_no3 <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Dissolved N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(axis.text.x = element_blank(),
        legend.position = "none")

plt_n2o_no3_area <-
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab("") +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

plt_sat_no3_area <-
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = sat_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab(expression(paste("NO"[3], " category"))) +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  theme(legend.position = "none",
        axis.text.y = element_blank())

plt_sat_area_no3 <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = sat_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("log(surface area (ha))") +
  ylab("Saturation ratio") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_fill_brewer(palette = "Greys", guide = "none") +
  theme(legend.position = "none")

legend1 <- effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  theme_void() +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(legend.position = c(0.5, 0.1),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = expression(paste("NO"[3], " category"))) +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 0.5))

legend1 <- get_legend(legend1)

legend2 <- 
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  theme_void() +
  theme(legend.position = c(0.5, 0.5),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = "log(surface area (ha))") +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 1))

legend2 <- get_legend(legend2)

legendPlot <- ggarrange(legend1, legend2, ncol = 1)

plt_area_effects <- ggarrange(plt_n2oeq_area,
                                  legendPlot,
                                  plt_n2o_area_no3,
                                  plt_n2o_no3_area,
                                  plt_sat_area_no3,
                                  plt_sat_no3_area,
                             ncol = 2,
                             nrow = 3,
                             widths = c(1, 1, 1, 1, 1, 1),
                             heights = c(1, 1, 1, 1, 1, 1),
                             labels = c("A", "Legend", "B", "C", "D", "E"),
                             hjust = c(-6, -1, -6, -6, -6, -6),
                             vjust = c(2, 2, 2, 2, 2, 2)
                             )

plt_area_effects <- plt_area_effects %>%
  annotate_figure(plt_area_effects,
                  left = text_grob("Posterior mean", 
                                   size = 18, 
                                   rot = 90)
                  )
# ggsave only works in R console (i.e., copy + paste to save)
ggsave(filename = "cond_effect_area_no3.tif",
       plot = plt_area_effects,
       device = "tiff",
       width = 180 / 25.4,
       height = 210 / 25.4,
       units = "in")
```


```{r plot_area_effects, fig.align='center', fig.asp=1.166667, fig.width=8, }
plt_area_effects
```

# Predict to population

As mentioned above, in order to make inferences to the population of interest, the final model above was used to, first, predict surface temperature in the target population, since it depended only on the fully observed covariates. Next, the predictive distribution for surface temperature was used, along with the relevant fully observed covariates, to predict NO3 in the target population. Finally, the predictive distributions for temperature and NO3 were used to predict the N2O responses. The code for these steps is outlined in the following.

The first step used the final model to predict surface temperature to the population:

```{r predict_obsframe, eval=FALSE, include=TRUE}
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sframe.rda")
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod6.rda")

predict_temp <- sframe %>%
  mutate(jdate = 205) %>%
  add_predicted_draws(n2o_mod6, resp=c("surftemp"), 
                      allow_new_levels = TRUE, 
                      cores =1, 
                      ndraws = 2000) %>%
  mutate(surftemp = .prediction)

save(predict_temp, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_temp_b.rda")
```

NO3 was next predicted using the posterior predictions for surface temperature and the other fully observed covariates. Note that only one posterior draw per posterior predictive draw for surface temperature was used in order to reduce excess simulations.

```{r parallel_predict_draws, eval=FALSE, include=TRUE}
temp_X <- predict_temp %>% # select relevant columns as predictors
  ungroup() %>%
  arrange(.draw) %>%
  select(.row, .draw, WSA9, state, size_cat, log_area, log_elev, surftemp)


rm(predict_temp) # reduce memory
gc()

# set number of cores to use for parallel predictions
# and register the workers
cl <- parallel::makeCluster(25)
doSNOW::registerDoSNOW(cl) 

# make a progress bar
pb <- txtProgressBar(max = 2000, 
                     style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

system.time( # approx x hrs with 25 workers & 1 draw from PPD
predict_no3 <- foreach(sub_X = isplitRows(temp_X, chunkSize = 465897), 
                       .combine = 'c',
                       .packages = c("brms"),
                       .options.snow = opts
                       ) %dopar% {
                         brms::posterior_predict(n2o_mod6,
                                                 newdata = sub_X,
                                                 resp = "no3cat",
                                                 allow_new_levels = T,
                                                 ndraws = 1,
                                                 cores = 1)
                         }
)

close(pb)
parallel::stopCluster(cl)

save(predict_no3, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_no3_b.rda")
```

Finally, dissolved and equilibrium N2O were predicted using the surface temperature and NO3 predictions, along with the survey variables and other fully observed covariates.

```{r n2o_covariates_X, eval=FALSE, include=TRUE}
# re-load the temp predictions into memory
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_temp_b.rda")

# Assemble dataframe containing relevant covariates (known and predicted) for predicting N2O responses.
n2o_X <- predict_temp %>%
  ungroup() %>%
  mutate(no3_cat = predict_no3) %>%
  select(WSA9,
         state,
         size_cat,
         log_area,
         surftemp,
         log_elev,
         no3_cat)

rm(predict_temp, predict_no3) # reduce memory

# set number of cores to use for parallel predictions
# and register the workers
cl <- parallel::makeCluster(25) 
doSNOW::registerDoSNOW(cl) 

# make a progress bar
pb <- txtProgressBar(max = 2000, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

# make predictions in parallel
system.time(
predict_n2o <- foreach(sub_X = isplitRows(n2o_X, chunkSize = 465897),
                 .combine = rbind,
                 .options.snow = opts,
                 .packages = c("brms")) %dopar% {
  apply(posterior_predict(n2o_mod6,
                          newdata = sub_X,
                          resp = c("n2o", "n2oeq"),
                          allow_new_levels = T,
                          ndraws = 1,
                          cores = 1), 3, t)
                   }
)

close(pb)
parallel::stopCluster(cl)

colnames(predict_n2o) <- c("n2o", "n2oeq")

save(predict_n2o, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_n2o_b.rda")
```

Finally, the predictions for all four partially observed responses were assembled into a new dataframe for use in inference:

```{r assemble_predictions, eval=FALSE, include=TRUE}
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_temp_b.rda")
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_no3_b.rda")
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_n2o_b.rda")

all_predictions <- predict_temp %>%
  ungroup() %>%
  mutate(no3cat = predict_no3) %>%
  bind_cols(predict_n2o) %>%
  mutate(n2osat = n2o / n2oeq, # calculate saturation ratio
         .row = rep(1:465897, each = 500),
         .draw = rep(seq(1,500, 1), 465897)) %>%
  mutate(area_ha = exp(log_area)) %>% # include area on ha scale
  select(WSA9,
         state,
         size_cat,
         area_ha,
         lat,
         lon,
         .row,
         .draw,
         surftemp,
         no3cat,
         n2o,
         n2oeq,
         n2osat)

save(all_predictions, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/all_predictions_b.rda")
```


# Population estimates

A number of estimates for the target population were assembled and presented below. First, the full posterior predictive distributions for dissolved N2O, equilibrium N2O, and the saturation ratio were assessed. These distributions summarized the predicted distribution of concentrations or ratios for all lakes in the population of interest and included parameter uncertainty propagated through the model. Next, population means were assessed, followed by comparisons of some model-based estimates to previously calculated design-based estimates.

## Posterior predictive distributions

Below, a density plot summarized the posterior predictive distributions across the target population of lakes. The summaries of the PPDs were based on 2000 draws. Note that the x-axis was truncated at 50 nmol/L for a clearer visualization of the bulk of the predictive distribution. For reference, the max predicted value was 4403.2 nmol/L for dissolved N2O, 20.4 nmol/L for dissolved N2O, and 793.5 for the saturation ratio. 

```{r plot_n2o_posterior_preds, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE, cache.lazy=FALSE}
all_predictions %>%
  group_by(.draw) %>% 
  slice_sample(n=1e4) %>% # simple random sample 10k lakes
  ggplot(aes(x = n2o)) +
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  scale_y_log10() +
  xlim(0, 50) +
  xlab("Dissolved N2O concentration") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_n2oeq_posterior_preds, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  slice_sample(n=1e4) %>% # simple random sample 10k lakes
  ggplot(aes(x = n2o)) +
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  scale_y_log10() +
  xlim(0, 50) +
  xlab("Equilibrium N2O concentration") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_sat_posterior_preds, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  slice_sample(n=1e4) %>% # simple random sample 10k lakes
  ggplot(aes(x = n2osat)) +
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  scale_y_log10() +
  xlim(0, 8) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```


## Estimated means

### National

Below are density plots summarizing the posterior distribution of _means_ for N2O concentrations and the saturation ratio for all US lakes and reservoirs > 4ha in the lower 48 states).

```{r plot_n2o_nat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(mean_n2o = mean(n2o)) %>%
  ggplot(aes(x = mean_n2o)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean dissolved N2O") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_n2oeq_nat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(mean_n2o = mean(n2oeq)) %>%
  ggplot(aes(x = mean_n2o)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean equlilibrium N2O") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_sat_nat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(mean_sat = mean(n2o/n2oeq)) %>%
  ggplot(aes(x = mean_sat)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```


To illustrate the skewness in the predictive distribution for the saturation ratio, an estimate for the median ratio is shown below. The entire posterior distribution of the mean above was larger than 1, which represents the boundary of under- _vs._ oversaturation. By comparison, the posterior estimate of the median below only included values less than one, suggesting that though the mean saturation ratio was likely greater than 1, most lakes in the national population were undersaturated (i.e., ratio less than 1). In distributions with strong right-skew, the mean can often be considerably larger than the median.


```{r plot_sat_nat_posterior_median, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(median_sat = median(n2o/n2oeq)) %>%
  ggplot(aes(x = median_sat)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("median N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

Below is a plot of the posterior mean estimate for the proportion of unsaturated lakes at the national scale.

```{r plot_undersat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row))) %>%
  ggplot(aes(x = prop_sat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  xlab("Proportion of undersaturated waterbodies") +
  ylab("density") +
  theme_tidybayes()
```

### Ecoregion

Below are posterior estimates of the means for dissolved and equilibrium N2O and the saturation ratio by WSA9 ecoregion.

```{r plot_n2o_wsa9_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = mean_n2o, 
                        y = reorder(ecoregion, mean_n2o)), 
                    quantiles = 100,
                    .width = c(0.5, 0.95)) +
  xlab("mean dissolved N2O") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_n2oeq_wsa9_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2oeq = mean(n2oeq), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = mean_n2oeq, 
                        y = reorder(ecoregion, mean_n2oeq)), 
                    .width = c(0.5, 0.95)) +
  xlab("mean equilibrium N2O") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_sat_wsa9_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_sat = mean(n2o/n2oeq), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = mean_sat,
                        y = reorder(ecoregion, mean_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("mean N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

A plot of the posterior estimates for the median saturation ratio below indicated that most lakes in each ecoregion were undersaturated (i.e., median < 1).

```{r plot_sat_wsa9_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(median_sat = median(n2o/n2oeq), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = median_sat,
                        y = reorder(ecoregion, median_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("median N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

A plot of the estimates of the proportion of under-saturated lakes by ecoregion is below.
These summaries again suggested that most lakes in each ecoregion were likely undersaturated (i.e., median << 1).

```{r plot_prop_sat_wsa9_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row)), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = prop_sat,
                        y = reorder(ecoregion, prop_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("Proportion of undersaturated lakes") +
  ylab("density") +
  theme_tidybayes()
```

### State

Comparisons of mean estimates by state are below. Density polygons were not included to minimize the vertical plot space.

```{r plot_state_mean_n2o, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate = round(median(mean_n2o), 1),
    LCL = round(quantile(mean_n2o, probs = 0.025), 1),
    UCL = round(quantile(mean_n2o, probs = 0.975), 1),
    .groups = "drop") %>% 
  select(state, estimate, LCL, UCL) %>%
  mutate(state = forcats::fct_reorder(state, estimate)) %>%
  ggplot(aes(x = state, y = estimate )) +
  geom_point(position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL),
                 position=position_dodge(width=0.5)) +
  ylab("mean dissolved N2O") +
  scale_y_continuous(position = "left") + 
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```


```{r plot_state_mean_n2oeq, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(mean_n2oeq = mean(n2oeq), .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate = round(median(mean_n2oeq), 1),
    LCL = round(quantile(mean_n2oeq, probs = 0.025), 1),
    UCL = round(quantile(mean_n2oeq, probs = 0.975), 1),
    .groups = "drop") %>% 
  select(state, estimate, LCL, UCL) %>%
  mutate(state = forcats::fct_reorder(state, estimate)) %>%
  ggplot(aes(x = state, y = estimate )) +
  geom_point(position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL),
                 position=position_dodge(width=0.5)) +
  ylab("mean equilibrium N2O") +
  scale_y_continuous(position = "left") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

Below is a plot of estimates for the mean (black circles) and median (grey circles) saturation ratio by state. A horizontal, dashed, black line is shown at ratio = 1, indicating the boundary for under- _vs._ oversaturation. Only a few states (e.g., NV, DE) had median estimates that were 1 or greater, suggesting that, for most states, most lakes were estimated to be undersaturated.

```{r plot_state_mean_median_sat, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(mean_sat = mean(n2osat), 
            median_sat = median(n2osat),
            .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate_mean = round(median(mean_sat), 4),
    LCL_mean = round(quantile(mean_sat, probs = 0.025), 4),
    UCL_mean = round(quantile(mean_sat, probs = 0.975), 4),
    estimate_median = round(median(median_sat), 4),
    LCL_median = round(quantile(median_sat, probs = 0.025), 4),
    UCL_median = round(quantile(median_sat, probs = 0.975), 4),
    .groups = "drop") %>% 
  select(state, 
         estimate_mean, 
         estimate_median, 
         LCL_mean,
         LCL_median,
         UCL_mean,
         UCL_median) %>%
  mutate(state = forcats::fct_reorder(state, estimate_mean)) %>%
  ggplot(aes(x = state, y = estimate_mean )) +
  geom_point(position=position_dodge(width=0.5),
             size = 2) +
  geom_linerange(aes(ymin = LCL_mean, ymax = UCL_mean),
                 position=position_dodge(width=0.5)) +
  geom_point(aes(x = state, y = estimate_median), 
             position=position_dodge(width=0.5),
             color = "grey",
             size = 2) +
  geom_linerange(aes(ymin = LCL_median, ymax = UCL_median),
                 position=position_dodge(width=0.5),
                 color = "gray") +
  ylab("mean and median N2O saturation ratio") +
  scale_y_continuous(position = "left") +
  geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

Finally, a plot of the estimated proportion of undersaturated lakes for each state in the target population. Point estimates are the posterior median of the proportion and bars are the upper and lower boundaries of the central 95th percentile of the posterior distributions of proportions.

```{r plot_state_prop_sat, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row)),
            .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate = round(median(prop_sat), 4),
    LCL = round(quantile(prop_sat, probs = 0.025), 4),
    UCL = round(quantile(prop_sat, probs = 0.975), 4),
    .groups = "drop") %>% 
  select(state, 
         estimate, 
         LCL,
         UCL) %>%
  mutate(state = forcats::fct_reorder(state, estimate)) %>%
  ggplot(aes(x = state, y = estimate)) +
  geom_point(position=position_dodge(width=0.5),
             size = 2) +
  geom_linerange(aes(ymin = LCL, ymax = UCL),
                 position=position_dodge(width=0.5)) +
  ylab("Proportion of undersaturated lakes") +
  scale_y_continuous(position = "left") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

### Size category

The estimated means and medians by size category are below for dissolved and equilibrium N2O and the saturation ratio.

```{r plot_n2o_size_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2o),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean dissolved N2O") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_n2oeq_size_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2oeq),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean equilibrium N2O") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_sat_size_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2osat),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
  xlab("mean N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```


```{r plot_sat_size_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = median(n2osat),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
  xlab("median N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

Mean _vs._ median below.

```{r plot_size_cat_mean_median_sat, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_sat = mean(n2osat), 
            median_sat = median(n2osat),
            .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate_mean = round(median(mean_sat), 2),
    LCL_mean = round(quantile(mean_sat, probs = 0.025), 2),
    UCL_mean = round(quantile(mean_sat, probs = 0.975), 2),
    estimate_median = round(median(median_sat), 2),
    LCL_median = round(quantile(median_sat, probs = 0.025), 2),
    UCL_median = round(quantile(median_sat, probs = 0.975), 2),
    .groups = "drop") %>% 
  select(size_cat, 
         estimate_mean, 
         estimate_median, 
         LCL_mean,
         LCL_median,
         UCL_mean,
         UCL_median) %>%
  mutate(state = forcats::fct_reorder(size_cat, estimate_mean)) %>%
  ggplot(aes(x = size_cat, y = estimate_mean )) +
  geom_point(position=position_dodge(width=0.5),
             size = 2) +
  geom_linerange(aes(ymin = LCL_mean, ymax = UCL_mean),
                 position=position_dodge(width=0.5)) +
  geom_point(aes(x = size_cat, y = estimate_median), 
             position=position_dodge(width=0.5),
             color = "grey",
             size = 2) +
  geom_linerange(aes(ymin = LCL_median, ymax = UCL_median),
                 position=position_dodge(width=0.5),
                 color = "gray") +
  ylab("mean and median N2O saturation ratio") +
  scale_y_continuous(position = "left") +
  geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

And, finally, the estimated proportion of undersaturated lakes in the target population by size category.

```{r plot_prop_sat_size_cat_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row)), .groups = "drop") %>%
  ggplot() + 
  stat_slabinterval(aes(x = prop_sat,
                        y = reorder(size_cat, prop_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("Proportion of undersaturated lakes") +
  ylab("density") +
  theme_tidybayes()
```

## Model- _vs._ design-based

Below, estimates from the model-based approach are compared to previously calculated, design-based estimates. In general, the model-based estimates were similar to the design-based estimates. The model-based estimates were typically within the confidence bounds of the design-based estimates, but with much greater precision. Improved precision was expected due to the "shrinkage" induced by the multilevel parameterization, which affords some "borrowing" of information across the various levels of the survey factors. 

### Dissolved N2O

Below, National mean estimates for dissolved N2O from the model and design-based approaches were compared. The sample-based estimate was also included as a reference. The black, vertical, dashed line indicates the mean of the sample.

```{r n2o_means_national, message=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_n2o = mean(n2o)) %>%
  summarise(estimate = round(median(mean_n2o), 2), # posterior median
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2)) %>% 
  mutate(type = "model") %>%
  bind_rows(cbind(n2o_survey_ests[10, 2:4], type = rep("survey", 1))) %>%
  add_row(estimate = round(mean(df_model$n2o), 2),
          type = "sample") %>%
  print()
```


```{r plot_n2o_means_national, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_n2o = mean(n2o)) %>%
  summarise(estimate = round(median(mean_n2o), 2), # posterior median
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2)) %>% 
  mutate(type = "model") %>%
  bind_rows(cbind(n2o_survey_ests[10, 2:4], type = rep("survey", 1))) %>%
  mutate(cl_width = round(UCL - LCL, 2)) %>%
  ggplot(aes(x = type, y = estimate, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = round(mean(df_model$n2o), 2), 
             linetype = "dashed",
             color = "black") +
  ylab("mean N2O concentration") +
  ggtitle("National estimate comparison") +
  coord_flip() + 
  theme_tidybayes()
```

Below, estimates were compared by ecoregion.

```{r n2o_mean_wsa9, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2o = mean(n2o)) %>%
  group_by(WSA9, .groups = "drop") %>%
  summarise(estimate = round(median(mean_n2o), 2),
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2),
    .groups = "drop") %>% 
  mutate(ecoregion = factor(WSA9)) %>%
  mutate(type = "model") %>%
  select(ecoregion, estimate, LCL, UCL, type) %>%
  mutate(ecoregion = forcats::fct_reorder(ecoregion, estimate)) %>%
  bind_rows(cbind(n2o_survey_ests[-10,], type = rep("survey", 9))) %>%
  arrange(ecoregion) %>%
  print()
```


```{r plot_mean_n2o_wsa9, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(WSA9) %>%
  summarise(estimate = round(median(mean_n2o), 2),
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2),
    .groups = "drop") %>% 
  mutate(ecoregion = factor(WSA9)) %>%
  mutate(type = "model") %>%
  select(ecoregion, estimate, LCL, UCL, type) %>%
  mutate(ecoregion = forcats::fct_reorder(ecoregion, estimate)) %>%
  bind_rows(cbind(n2o_survey_ests[-10,], type = rep("survey", 9))) %>%
  ggplot(aes(x = ecoregion, y = estimate, group = type, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  coord_flip() + 
  theme_tidybayes() +
  ylab("mean dissolved N2O") +
  ggtitle("Ecoregion estimates comparison")
```

Means were compared according to size categories below.

```{r table_size_mean_n2o, echo=FALSE,message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_n2o), 1),
    LCL = round(quantile(mean_n2o, probs = 0.025), 1),
    UCL = round(quantile(mean_n2o, probs = 0.975), 1),
    .groups = "drop") %>%
  mutate(type = "model") %>%
  bind_rows(cbind(n2o_survey_ests_size, type = rep("survey", 5))) %>%
  mutate(size = factor(size_cat)) %>%
  mutate(size = forcats::fct_reorder(size, estimate)) %>%
  mutate(cl_width = UCL - LCL) %>%
  arrange(size) %>%
  select(size, estimate, LCL, UCL, type) %>% 
  print()
```


```{r plot_size_mean_n2o, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_n2o), 2),
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2),
    .groups = "drop") %>% 
  #mutate(size_cat = factor(size_cat)) %>%
  mutate(type = "model") %>%
  select(size_cat, estimate, LCL, UCL, type) %>%
  bind_rows(cbind(n2o_survey_ests_size, type = rep("survey", 5))) %>%
  mutate(size_cat = forcats::fct_reorder(size_cat, estimate)) %>%
  ggplot(aes(x = size_cat, y = estimate, group = type, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  coord_flip() + 
  theme_tidybayes() +
  ylab("mean dissolved N2O") +
  ggtitle("Size category estimates comparison")
```

### Saturation

Below, the same comparisons were made for the saturation estimates.

```{r table_nat_sat_mean, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_sat = mean(n2osat), .groups = "drop") %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3),
    .groups = "drop") %>% 
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests[10, 2:4], type = rep("survey", 1))) %>%
  add_row(estimate = round(mean(df_model$n2o / df_model$n2o_eq), 3),
          type = "sample") %>%
  print()
```


```{r plot_nat_sat_mean, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_sat = mean(n2osat)) %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3)) %>%  
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests[10, 2:4], type = rep("survey", 1))) %>%
  ggplot(aes(x = type, y = estimate, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = round(mean(df_model$n2o / df_model$n2o_eq), 3), 
             linetype = "dashed",
             color = "black") +
  ylab("mean N2O saturation ratio") +
  ggtitle("National estimates comparison") +
  coord_flip() + 
  theme_tidybayes()
```


```{r plot_wsa9_sat_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise( mean_sat = mean(n2osat), .groups = "drop") %>%
  group_by(WSA9) %>%
  summarise( estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3),
    .groups = "drop") %>% 
  mutate(ecoregion = factor(WSA9)) %>%
  mutate(type = "model") %>%
  mutate(ecoregion = forcats::fct_reorder(ecoregion, estimate)) %>%
  select(ecoregion, estimate, LCL, UCL, type) %>%
  bind_rows(cbind(sat_survey_ests[-10,], type = rep("survey", 9))) %>%
  mutate(cl_width = UCL - LCL) %>%
  ggplot(aes(x = ecoregion, y = estimate, group = type, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = 1, color = "lightgrey") +
  ylab("mean N2O saturation ratio") +
  ggtitle("Ecoregion estimates comparison") +
  coord_flip() + 
  theme_tidybayes()
```


```{r table_size_sat_mean, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_sat = mean(n2osat), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3)) %>%
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests_size, type = rep("survey", 5))) %>%
  mutate(size = factor(size_cat)) %>%
  mutate(cl_width = UCL - LCL) %>%
  arrange(size) %>%
  select(size, estimate, LCL, UCL, type) %>% 
  print()
```


```{r plot_size_sat_mean, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_sat = mean(n2osat), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3),
    .groups = "drop") %>%
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests_size, type = rep("survey", 5))) %>%
  mutate(size = factor(size_cat)) %>%
  select(size, estimate, LCL, UCL, type) %>% 
  ggplot(aes(x = size, y = estimate, group = type, color = type)) +
  geom_point(position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = 1, color = "lightgrey") +
  ylab("mean N2O saturation ratio") +
  ggtitle("Size category estimates comparison") +
  coord_flip() + 
  theme_tidybayes()
```

# Session Info

```{r session}
sessionInfo()
```

# References
