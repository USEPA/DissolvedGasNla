---
title: "Modeling workflow: NLA N2O survey data"
author: "Roy Martin, Jake Beaulieu, Michael McManus"
date: "`r Sys.Date()`"
output:
  github_document:
    number_sections: TRUE
    df_print: "tibble"
    math_method: 
      engine: webtex
    #  url: https://latex.codecogs.com/svg.image?
    html_preview: TRUE
    keep_html: TRUE
bibliography: RWM_Endnote_Library.bib
link-citations: yes
editor_options:
  chunk_output_type: inline
  markdown: 
    wrap: 72
---

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
library(ggpubr)
library(moments)
library(ggplot2)
library(ggExtra)
library(gridExtra)
library(kableExtra)
library(ggrepel)
library(dplyr)
library(tidyverse)
library(tidyr)
library(future)
library(foreach)
library(itertools)
library(bayesplot)
library(tidybayes)
library(brms)
library(tictoc)
library(arrow)
library(archive)

options(mc.cores = parallel::detectCores(logical = FALSE))
options( max.print = 1000 )

# Identify local path for each user
localPath <- Sys.getenv("USERPROFILE")

# Define helper functions
# standardized formatting for column names
toEPA <- function(X1){
  names(X1) = tolower(names(X1))
  names(X1) = gsub(pattern = c("\\(| |#|)|/|-|\\+|:|_"), replacement = ".", x = names(X1))
  X1
}

# stat: skew 
skew <- function(x) {
  xdev <- x - mean(x)
  n <- length(x)
  r <- sum(xdev^3) / sum(xdev^2)^1.5
  return(r * sqrt(n) * (1 - 1/n)^1.5)
}

# Load model and data objects from drive for knitting (if they already exist)
## vector of object names
objs <- c("dg",
          "df_model",
          "df_test",
          "sframe",
          "pframe",
          "samp_props",
          "n2o_mod1",
          "n2o_mod2",
          "n2o_mod3",
          "n2o_mod4",
          "n2o_mod5",
          "n2o_mod6",
          "all_predictions_b"
          )

N <- length(objs)

# list of file paths for objects saved
f <- list()
for(i in 1:N){
    f[i] <- paste0("./../modelFiles/",
    objs[i], ".rda")
    }

# load files if they exist
for(i in 1:N){
  if(file.exists(f[[i]]))
    load(f[[i]])
}

# clean up workspace
rm(f, i, objs, N)
```

# Introduction

This supplement documents the modeling workflow used for estimating
dissolved and equilibrium N2O gas concentrations and saturation ratios
for freshwater lakes (natural and man-made) across the continental
United States (CONUS). Data for the estimates came from the 2017 Nation
Lakes Assessment (NLA) survey, which aimed to provide representative
samples for describing environmental conditions across CONUS lakes
during the summer index period of 2017 [@USEPA_NLA_DESIGN_2017]. The
population of interest (POI) for this study was defined as all lakes and
reservoirs in the CONUS that were (1) larger than 1 hectare, (2) with at
least 0.1 hectares of open water, (3) at least 1 meter deep, and (4)
with a residence time of less than 1 week. The 2017 NLA sampling frame
consisted of 465,897 lakes delineated from georeferenced data documented
in the National Hydrography Dataset (NHD). The samples were drawn
according to a spatially balanced, stratified, and unequal probability
design. Sampling was stratified among categories of lake size (surface
area in hectares), WSA9 ecoregion, and US state (excluding AK and HI).
The probability of selection was greater for larger lakes relative to
smaller ones in order to sufficiently represent larger lakes in a sample
of practical size. Small lakes vastly outnumber large ones in the POI.

The POI was defined in this study explicitly by the NLA 2017 sampling
frame ([@USEPA_NLA_DESIGN_2017]). Therefore, the effective and stated
POI may depart in important ways that would be difficult to confirm in
practice. For example, it would be impractical to visit all lakes in the
sampling frame to determine which contained less than 0.1 ha of open
water or were less than 1 meter deep. These conditions were evaluated in
the field for sites that were sampled. If a field crew arrived at a site
that did not meet the conditions for inclusion, another site could be
chosen from an oversample frame. In effect, the size of the stated POI
is likely smaller than the 465,897 lakes described in the sampling frame
and, therefore, the possibility of some remaining biases in these
estimates should be considered, if only to emphasize that there remains
uncertainty in the population-level estimates beyond what was estimated
from modeling. Though it may be practically impossible to determine the
precise magnitude or direction in which any particular estimate could be
biased, it is clear that estimates could vary systematically given any
substantial mismatches between the POI and the sampling frame.

When making inferences to a POI from a sample, estimates should be
adjusted to address potential biases resulting from known differences
between the POI and sample. For this study, lakes in the POI were
missing from the sample not completely at random, but systematically and
according to the probability assigned by the survey design. This type of
"missingness" is not ignorable for making inferences from a sample, but
may be considered ignorable if the inferences are adjusted such that
they are conditional on the survey design [@Gelman_etal_2014, Ch. 8;
@Gelman_etal_2020 Ch. 17]. A straightforward approach to adjustment is
to simply include the design variables as predictors in a regression
model for the surveyed responses of interest [@Gelman_etal_2020, Ch.
17]. Then, in a second step referred to as "poststratification"
[@Gelman_etal_2020, Ch. 17], the model parameter estimates can be used
to make population-level estimates by summarizing over the known
distribution of the design variables in the POI or sub-populations
therein. Multilevel regression models are often preferred in this
approach, which is why it is often referred to as multilevel regression
with poststratification, or MRP [@Park_etal_2004; @Gelman_Little_1997;
@Gelman_etal_2020, Ch. 17; @Kennedy_Gelman_2021]. Multilevel regression
models are recommended because they naturally provide regularized
estimates along the design groupings, which can improve out-of-sample
inferences [@Gelman_Little_1997]. Likewise, estimates for group levels
that may be missing from the sample (e.g., an unsampled U.S. state), but
are part of the POI, are straightforward using the multilevel approach
[@Gelman_etal_2020 Ch. 17; @McElreath_2020]. For a worked and narrated
example using this approach, see a recent paper by Kennedy and Gelman
[@Kennedy_Gelman_2021]. For an example in the context of national
surveys of environmental resources, see a recent paper from Zachmann and
others [@Zachmann_etal_2022].

In this study, we used the 2017 NLA survey data and an adjustment
approach similar to MRP to provide population-level estimates for (1)
dissolved and equilibrium N2O concentrations; (2) the N2O saturation
ratio (i.e., dissolved N2O/equilibrium N2O); and (3) the proportion of
under-saturated water bodies (i.e., saturation ratio \< 1). The
resulting estimates were later combined with lake-level attributes
(e.g., surface area) to provide estimates of N2O emission rates and
flux. A number of Bayesian multilevel regression models were fit to the
survey data and predictions from those models were checked against both
the data used in their fitting as well as a subset of held-out data from
re-visited sites. Because dissolved and equilibrium N2O were each
observed on the same sample units (a single site within each waterbody),
our regression models were constructed to estimate their joint
probability distribution. The multivariate response allowed for
conditional dependencies between dissolved and equilibrium N2O due to,
for example, physiography. Although predictions from separate models for
each N2O response may have provided comparable estimates, a joint model
was expected to better capture uncertainty and potentially improve
out-of-sample predictions, should the data be conditionally correlated
[@Warton_etal_2015; @Poggiato_etal_2021]. The saturation ratio
(saturation = dissolved N2O/equilibrium N2O) was estimated as a derived
quantity calculated from the joint posterior predictive distribution of
the two N2O variables.

Our initial regression models were focused on conditioning the N2O data
on the survey design factors only, which included multilevel groupings
of the sampled lakes according to WSA9 ecoregion, states within
ecoregions, and size classes within states. Although these initial
models performed well at replicating the observed group-level means,
further model checking indicated that they did a relatively poor job of
replicating some tail properties, such as the long right tail of the
observed dissolved N2O data. As a result of this misfit, the predictive
distribution for the saturation ratio was also consistently biased low
relative to the observed data. In subsequent models, we found that
including an NO3 covariate was particularly helpful for better
replicating these extreme values. The addition of predictors for surface
temperature and lake surface area, along with interaction terms for
these predictors with NO3, also lead to apparent improvements. Likewise,
the inclusion of surface temperature and elevation covariates in the
equilibrium N2O response resulted in improvements over the initial
models, as did added flexibility in the distributional terms
(heterogeneous errors) for both dissolved and equilibrium N2O.

A number of additional, potentially relevant covariates were evaluated
in exploratory analyses and models, but are not covered in this
document. These variables are, however, available to the public should
the reader wish to further explore their utility. These measures, which
were taken at the time of N2O sampling or constructed from those
measures, included chlorophyll a concentration, dissolved oxygen (DO)
content at the surface, and a buoyancy metric. Some of these variables
are also covered in the data munging document at:
<https://github.com/USEPA/DissolvedGasNla/blob/master/scripts/dgIndicatorAnalysis.html>.
An exploratory analysis using classification trees in that document
suggested that NO3 as well as both mean depth and chlorophyll a
concentration were associated with dissolved N2O concentration. The
decision to not include these variables in the final model was based on
several issues. First, our primary goal was to make population-level
estimates for N2O while considering the survey design structure. As a
result, we were less concerned with exploring the relative contributions
of environmental correlates to N2O variation. However, our initial
models excluding all covariates proved to result in relatively poor fits
to important aspects of the observed data. In an attempt to improving
the fit, the NO3 covariate was then included due to the relatively large
effects implied in exploratory analyses (see "Sample Data Exploration"
to follow). Conversely, our evaluations of exploratory plots and models
with chlorophyll a, surface DO, and the BF covariates did not result in
similarly substantial improvements. Second, these other covariates were
only available in the sample and, therefore, were not fully observed in
the POI. As such, using them to make population-level predictions would
have come with additional complexity (discussed below) that didn't
appear to be reciprocated by critical improvements in model fit.
Finally, several observations were missing from the sample for these
covariates. To include them in our model would have required sub-models
for the missing data, resulting in added complexity and computational
burden that, again, did not appear to be worth the added complexity and
computational burden. Hence, the progression of models presented in this
supplement was intended to efficiently convey the improvements in fit
following the addition of key covariates and parameterizations that
ultimately comprised the final model.

The first regression model we fit was constructed to estimate the joint
distribution of log-transformed dissolved and equilibrium N2O
conditional only on the the survey design factors, such that:

$$Y \sim MVN(\nu, \Sigma)$$

Indexing to each response, $p$:

$$Y = [y_{p=1}, y_{p=2}] \sim MVN(\nu = [\mu_{p=1}, \mu_{p=2}], \Sigma)$$

Indexing to the observation level, $i$, within each response:

$$\mu_{pijkl} = \alpha_{0(pi)} + \alpha_{1(pij)} + \alpha_{2(pijk)} + \alpha_{3(pijkl)}$$

$$\alpha_1 \sim MVN(0, \Lambda_1)$$ $$\alpha_2 \sim MVN(0, \Lambda_2)$$
$$\alpha_3 \sim MVN(0, \Lambda_3)$$

$$\Lambda_{\alpha = 1,..,3} = \begin{pmatrix} 1 & \tau ^2_{p=1} \\ \tau^2_{p=2} & 1 \end{pmatrix} \chi_{\alpha = 1,..,3} \begin{pmatrix} 1 & \tau^2_{p=1} \\ \tau^2_{p=2} & 1 \end{pmatrix}$$

$$\chi_{\alpha = 1,..,3} = \begin{pmatrix} 1 & \varrho_{p1,p2} \\ \varrho_{p1,p2} & 1 \end{pmatrix}$$

$$\Sigma = \begin{pmatrix} 1 & \sigma^2_{p=1} \\ \sigma^2_{p=2} & 1 \end{pmatrix} \Omega \begin{pmatrix} 1 & \sigma^2_{p=1} \\ \sigma^2_{p=2} & 1 \end{pmatrix}$$
$$\Omega = \begin{pmatrix} 1 & \rho_{p1,p2} \\ \rho_{p1,p2} & 1 \end{pmatrix}$$

Each log-transformed observation, $i \in 1,..,N=984$, for each N2O
response variable, $p \in 1:P=2$, was assumed to be drawn from a
multivariate normal (MVN) distribution with the parameters $\nu$ and
$\Sigma$, where $\nu$ is the multivariate mean and $\Sigma$ is a
covariance matrix containing the observation-level variances and
(residual) correlations.

The multivariate mean was defined by a vector of location parameters,
$\nu = [\mu_{p=1}, \mu_{p=2}]$, for each response, $p$. As noted above,
each location parameter was also defined according to a linear
combination of parameters indexed to each response $p$ and observation
$i$. This linear combination included a fixed global intercept,
$\alpha_0$, conditioned on the data, and three latent group-level
effects matrices, $\alpha_1, \alpha_2, \alpha_3$. The effects in each of
these matrices were also drawn from MVN probability distributions
centered on zero in $p$-dimensional space. The spread of the effects
around zero were determined by a corresponding variance-covariance
matrix, $\Lambda_1, \Lambda_2, \text{or } \Lambda_3$. The standard
deviation parameters, $\tau$ , of those matrices were conditioned on the
data and captured group-level standard deviations that controlled the
spread of the group-level effects for each response. The $\chi$
parameter contained the group-level residual correlation matrix, wherein
$\varrho$ denotes the group-level residual correlations (i.e., between
responses).

The explicit indexing in the notation above conveys the relationship
between the parameters and each observation, $i$, and emphasizes the
nested structure of the observations within the group effects.
Specifically, each observation, $i$, was nested in a lake size category,
$l$, which was nested in a state, $k$, and ecoregion, $j$. The
group-level effects in $\alpha_1$, therefore, accounted for
ecoregion-level deviations from the global mean; $\alpha_2$ accounted
for state-level group effects nested in ecoregions; and $\alpha_3$
accounted for lake size category effects within states and ecoregions.

Finally, the observation-level covariance term, $\Sigma$, comprised of
the observation-level standard deviations, $\sigma$, for each response,
and $\Omega$ or the observation-level residual correlation matrix,
wherein $\rho$ captured residual correlation between responses.

For model fitting, priors were needed for all parameters conditioned
directly on the data, which included the global intercepts, $\alpha_0$;
the scale parameters of the latent group effects, $\tau$ and $\sigma$;
and the correlation parameters, $\varrho$ and $\rho$. A normal or
Gaussian prior, $N(\mu = 2, \sigma = 1)$ centered near the (log-scale)
data means, was used as the prior for the global mean parameter for each
response. This prior was considered minimally informative as it placed
most (\~80%) of the prior mass over values between about 2 and 27 ng/L
for median N2O and median N2O equilibrium concentration; and included
support in the tails for values approaching 0 ng/L on the lower end and
80 ng/L on the high end. We placed $Exp(2)$ priors over all scale
parameters, which placed most of the support between values very close
to 0 and values near 1 (central 80% density interval from approximately
0.005 to 1.15). Finally, for the correlation matrices, an $LKJ(\eta =2)$
prior was used, which, for a 2-dimensional response, placed most support
for correlations between approximately -0.9 and 0.9. This prior seemed
reasonable as there is no direct causal link between these responses
that would warrant a very strong correlation . Any residual dependence
was expected to be conditional or indirect due to, for example, a common
correlate (e.g., elevation, temperature). For more information on prior
choice recommendations in Stan, see:
<https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations>

The $\textbf{brms}$ package [@Burkner_2017] for $\textbf{R}$
[@R_Core_Team_2021] was used to fit all of the models in a fully
Bayesian setting. The formula syntax of the $\textbf{brms}$ package is
similar to the syntax used in the $\textbf{lme4}$ package that is widely
used to fit mixed effects models in frequentist settings. In either
package, the linear predictor for $\mu$ described above, but ignoring
multivariate dependencies, would be expressed as:

$$\sim 1 + (1|WSA9) + (1|WSA9:state) + (1|WSA9:state:size)$$

In the $\textbf{brms}$ package, there is additional functionality and
formula syntax for multivariate responses, which allows for the varying
intercepts of the separate linear predictors in a multivariate model to
be correlated across responses, e.g.,:

$$
\begin{aligned} 
  N_2O_{diss} \sim 1 + (1|a|WSA9) + (1|b|WSA9:state) + (1|c|WSA9:state:size) \\
  N_2O_{equi} \sim 1 + (1|a|WSA9) + (1|b|WSA9:state) + (1|c|WSA9:state:size) 
\end{aligned}
$$

The above formula syntax indicates that the linear predictor for both
N2O responses have the same group-level varying effects terms, and that
the effects associated with each of those terms can be correlated across
responses. The relevant sections of $\textbf{R}$ code that are helpful
for describing the first model above using $\textbf{brms}$ syntax are
below:

```{r model_1_text, eval=FALSE, include=TRUE}
# Assign separate linear predictors for the dissolved and equilibrium N2O responses
bf_n2o <- bf(log(n2o) ~ 1 + 
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ 1 + 
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) +
               (1 | c | WSA9:state:size_cat),
             family = gaussian())

# Set priors for parameters
priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"), # alpha_0
  prior(exponential(2), class = "sd", resp = "logn2o"), # sd alpha_1..3
  prior(exponential(2), class = "sigma", resp = "logn2o"), # observation level sd
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"),
  prior(exponential(2), class = "sigma", resp = "logn2oeq"),
  prior(lkj(2), class = "rescor"), # observation level residual correlation
  prior(lkj(2), class = "cor") # correlation for group effects
  )

# Fit the multivariate model
n2o_mod1 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE), ...)
```

The first two objects assigned in the above code example are the linear
predictors assigned to the dissolved and equilibrium N2O responses. The
second object is a list of priors as defined above. The third object
results from the `brm()` call to fit the model. In this syntax, the two
linear predictor objects are "added" along with the
`set_rescor(rescor = TRUE)` option, which defines whether the residual
correlation is to be modeled (TRUE) or not (FALSE). Note that, with
`set_rescor(rescor = FALSE)` and without the correlated group effects
(i.e., 'a', 'b', 'c'), $\textbf{brms}$ would effectively treat the two
responses as entirely independent in fitting.

For the remainder of this document, only this simplified syntax is
presented to describe the model structure. For more information on
$\textbf{brms}$ functionality and syntax with multivariate response
models, see the package vignette:
<https://cran.r-project.org/web/packages/brms/vignettes/brms_multivariate.html>.

The relevant code for the final model used for inference and described
in the main paper is below:

```{r model_final_text, eval=FALSE, include=TRUE}
# Assign separate linear predictors for each response: N2O, N2o-eq, Surface temp, and NO3 level.

# N2O
bf_n2o <- bf(n2o ~ mo(no3_cat) +
               log_area +
               surftemp + 
               mo(no3_cat):log_area +
               mo(no3_cat):surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             shape ~ log_area +
               mo(no3_cat) +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = Gamma(link = "log"))

# Equilibrium N2O
bf_n2oeq <- bf(n2o_eq ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             shape ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = Gamma(link = "log"))

# Surface temperature
bf_temp <- bf(surftemp ~ lat +
                s(log_elev) +
                s(jdate) +
                (1 | a | WSA9) + 
                (1 | b | WSA9:state) +
                (1 | c | WSA9:state:size_cat),
              shape ~ lat,
              family = Gamma(link = "log"))

# NO3 level
bf_no3 <- bf(no3_cat ~ surftemp +
               log_area +
               (1 | a | WSA9) +
               (1 | b | WSA9:state) +
               (1 | c | WSA9:state:size_cat),
             family = cumulative(link = "logit", threshold="flexible"))

# Assign priors 
priors <- c( # N2O
  prior(normal(2, 1), class = "Intercept", resp = "n2o"),
  prior(normal(0, 1), class = "b", resp = "n2o"),
  prior(exponential(2), class = "sd", resp = "n2o"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "n2o"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "n2o"),
  prior(exponential(2), class = "sd", dpar = "shape", resp = "n2o"),
  
  # Equil N2O
  prior(normal(2, 1), class = "Intercept", resp = "n2oeq"), 
  prior(normal(0, 1), class = "b", resp = "n2oeq"),  
  prior(exponential(2), class = "sd", resp = "n2oeq"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "n2oeq"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "n2oeq"),
  prior(exponential(2), class = "sd", dpar = "shape", resp = "n2oeq"),
  
  # Surface temp
  prior(normal(3, 1), class = "Intercept", resp = "surftemp"), 
  prior(normal(0, 1), class = "b", resp = "surftemp"), 
  prior(exponential(0.5), class = "sds", resp = "surftemp"),
  prior(exponential(2), class = "sd", resp = "surftemp"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "surftemp"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "surftemp"),
  
  # NO3
  prior(normal(0, 3), class = "Intercept", resp = "no3cat"),
  prior(normal(0, 1), class = "b", resp = "no3cat"),
  prior(exponential(1), class = "sd", resp = "no3cat"),
  
  prior(lkj(2), class = "cor")
  )

# Fit the multivariate model
n2o_mod6 <- brm(bf_n2o + bf_n2oeq + bf_temp + bf_no3 + set_rescor(rescor = FALSE), ...)
```

In this final model, the dissolved and equilibrium N2O responses were
each modeled with Gamma distributed errors. The Gamma error structure
appeared to result in slightly better performance in the predictive
checks compared to the Gaussian errors. This was primarily apparent in
the saturation ratio checks, which may have been more sensitive to model
performance in the tails of the N2O responses. Others have indicated
that the Gamma error distribution can work well for modeling dissolved
N2O data [@Webb_etal_2019]. The linear predictor for dissolved N2O
included the survey design effects along with covariate terms for lake
area (ha), NO3 level, and surface water temperature. To accomodate
heterogeneous errors, the shape parameter of the Gamma distribution was
modeled as a function of NO3 level, lake area, and the survey design
factors. The equilibrium N2O response was modeled as a function of the
survey design factors, lake elevation, and lake surface temperature. The
shape parameter was, again, allowed to vary conditional on the survey
factors, surface temperature, and elevation.

The sub-model for the surface temperature response also assumed a Gamma
distributed error distribution and covariates included the survey design
variables, latitude, elevation, and Julian date. The shape parameter was
also modeled as a function of latitude to address increasing temperature
variance along the latitudinal gradient.

The NO3 sub-model was a cumulative logit model and the linear predictor
included all of the survey factors as well as surface temperature and
lake area.

Note that there was no observation-level residual correlation term for
this final model, since the residuals are undefined for the Gamma and
cumulative logit models. Dropping the observation-level residual
correlation term was deemed a reasonable compromise that enabled the
inclusion of NO3 as a covariate on dissolved N2O. The random intercepts,
however, still allowed for potential correlations between the four
responses at the group levels. As mentioned previously, including
covariates that were not available in the full POI necessitated some
additional steps in the poststratification process. To make
population-level inferences from a model with covariates, those
covariates need to be (1) fully observed across the POI or (2) their
"missingness" needs to be addressed with modeling. For the lake area and
elevation covariates, for example, data was available for the entire POI
from previously compiled geospatial databases. However, neither surface
temperature or NO3 were observed for lakes outside of the sample. That
is, they were partially observed with respect to the POI. Therefore, the
final multivariate model, coded above included these as additional
responses, with each also being conditioned on the survey design
structure and the fully observed covariates. The dependence structure
among the fully and partially observed variables in this model could be
described such that:

$$\begin{aligned} 
{p( \boldsymbol{N_2O_{diss}}} &| Survey, Area, {\boldsymbol{NO_3}}, {\boldsymbol{Temp}}) \\ 
{p( \boldsymbol{N_2O_{equil}}} &| Survey, Elev, {\boldsymbol{Temp}})\\
{p( \boldsymbol{NO_3}} &| Survey, Area, {\boldsymbol{Temp}}) \\ 
{p( \boldsymbol{Temp}} &| Survey, Lat, Elev, Day)
\end{aligned}$$

Variables in bold text above were partially observed with respect to the
POI (i.e., observed only in the sample), whereas variables not in bold
were considered fully observed. The partially observed variables, being
dissolved and equilibrium N2O, NO3, and surface temperature, were each
modeled conditional on the survey design variables and other partially
and/or fully observed covariates. This piece-wise approach then required
a more complex set of post-processing steps compared to a typical MRP
analysis. In order to propagate uncertainty through to the
population-level inferences, the fitted model was first used to predict
surface temperature in the target population, since it depended only on
the fully observed covariates. That predictive distribution was then
used alongside the relevant fully observed covariates to predict NO3 in
the target population. Finally, these predictive distributions for
temperature and NO3 were used to predict the N2O responses. These steps
were carried out in the "Predict to population" section below. This
approach is similar to MRP approaches with "non-census" variables
[@Kastellec_etal_2015]. It could also be described as a form of Bayesian
structural equation model [@Merkle_etal_2021; @Merkle_Rosseel_2018].

Finally, because N2O flux was to be later estimated as a function of
lake-level measures (*e.g.*, surface area), predictions for N2O were
made to each of the 465,897 individual lakes in the POI. For population
level estimates of dissolved N2O, equilibrium N2O, and N2O saturation,
the lake-level predictions were summarized across the relevant units
(*e.g.*, CONUS, ecoregion). Predictions were assumed relevant for
average conditions during the biological index period of 2017.

All of the models were constructed and assessed within in `R`
[@R_Core_Team_2021] using the `brms` package [@Burkner_2017] as an
interface to Stan, a software package for fitting fully Bayesian models
via Hamiltonian Monte Carlo [HMC, @Stan_Development_Team_2018_a;
@Stan_Development_Team_2018_b; @Stan_Development_Team_2018_c]. More
specific details on the model structures and fits is provided in the
"Model fitting" section below.

# Data

As explained in the data munging document document
(<https://github.com/USEPA/DissolvedGasNla/blob/master/scripts/dgIndicatorAnalysis.html>),
duplicate dissolved gas samples were collected at a depth of \~0.1m at
designated index sites distributed across 1091 lakes nationwide, of
which 95 were sampled twice as repeat visits. This subset of revisit
sites was used as a test set for assessing model fit and out-of-sample
performance.

Water samples were analyzed via gas chromotography and concentrations
were recorded to the nearest 0.001 nmol/L. As part of the survey design,
each gas observation was indexed to an individual lake selected with
unequal probability from 5 different lake size categories,
$j \in j=1,...,J = 5$, according to surface area (ha), and from within a
state, $k \in k=1,...,K = 48$, situated within an aggregated, WSA9 or
Omernik ecoregion, $l \in l=1,...,L = 9$. All WSA9 ecoregions were
represented, including the Xeric (XER), Western Mountain (WMT), Northern
Plains (NPL), Southern Plains (SPL), Temperate Plains (TPL), Coastal
Plains (CPL), Upper Midwest (UMW), Northern Appalachian (NAP), and
Southern Appalachian (SAP) regions. Gas data from the first and second
(follow-up) visits were separated, with $n=984$ *vs.* $n=95$
observations each. In addition to the design variables, a number of
potentially useful covariates were also indexed to the gas observations,
including measures of NO3, surface water temperature, elevation,
chlorophyll a content, dissolved oxygen content, and waterbody size
(hectares). These gas data and covariates were previously described and
munged at:
<https://github.com/USEPA/DissolvedGasNla/blob/master/scripts/dataMunge.html>.

## Import

That originally munged gas dataset is imported below.

```{r import_data, eval=FALSE, include=TRUE}
load("./inputData/dg.RData")
```

A new data frame for modeling was constructed from the original file,
including only the variables of interest: (1) the N2O gas observations;
(2) the survey design variables indexed to those observations; and (3)
measures and metrics considered potentially useful as covariates for
improving the fit and/or practical interpretation of the model. The
modeling data frame below excluded the second-visit observations, which
would later be used for model checking. Some variables from the imported
data were renamed for convenience. In addition, the NO3 covariate was
rounded according to the documented measurement precision and an
alternative version was created by log-transforming and re-coding the
variable as an ordered factor with five levels. The left-most cut point
separated observations below the detection limit from the completely
observed samples. The remaining cut points were drawn at equal distances
in the positive direction along the log scale.

```{r all_data_n, echo=TRUE, paged.print=TRUE}
dg %>%
  filter(sample.source == "DG") %>%
  nrow() # number of dissolved gas observations before filtering out probability sites and second visits
```

```{r model_data, eval=FALSE, include=TRUE}
df_model <- dg %>%
  filter(sample.source == "DG", # dissolved gas info
         sitetype == "PROB") %>% # probability samples only
  filter(visit.no == 1) %>% # first-visit sites only
  mutate(n2o = round(dissolved.n2o.nmol, 2),
         n2o_eq = round(sat.n2o.nmol, 2),
         n2o_sat = n2o.sat.ratio,
         n2o_em = e.n2o.nmol.d,
         n2o_flux = f.n2o.m.d,
         WSA9 = factor(ag.eco9),
         state = factor(state.abb[match(state.nm, state.name)]),
         area_ha = area.ha,
         log_area = log(area_ha),
         chla = chla.result,
         log_chla = log(chla),
         elev = elevation,
         log_elev = log(elev + 1),
         do_surf = o2.surf,
         log_do = log(do_surf),
         bf_max = max.bf,
         sqrt_bf = sqrt(bf_max),
         size_cat = recode(area.cat6, # simpler naming conventions for the size categories
                           "(1,4]" = "min_4" ,
                           "(10,20]" = "10_20",
                           "(20,50]" = "20_50",
                           "(4,10]" = "4_10",
                           ">50" = "50_max")) %>%
  mutate(size_cat = factor(size_cat,
                           levels = c("min_4", "4_10", "10_20", "20_50", "50_max"),
                           ordered = TRUE)) %>%
  mutate(no3 = ifelse(nitrate.n.result <= 0.0005, 0.0005, round(nitrate.n.result, 4))) %>%# 1/2 mdl 0.01
  mutate(no3_cat = cut(log(no3), # convert no3 to ordered factor with 5 levels
                       breaks = c(-Inf, -7.5, -5.5, -3.5, -1.5, Inf),
                       labels =seq(1, 5, 1))) %>%
  mutate(no3_cat = factor(no3_cat,
                          levels = seq(1, 5, 1),
                          ordered = TRUE)) %>%
  mutate(date = as.Date(date.col)) %>%
  mutate(jdate = as.numeric(format(date, "%j"))) %>% 
  mutate(lat = map.lat.dd,
         lon = map.lon.dd) %>% # longitude
  mutate(surftemp = surftemp,
         log_surftemp = log(surftemp)) %>% 
  select(WSA9,
         state,
         size_cat,
         site.id,
         lat,
         lon,
         date,
         jdate,
         surftemp,
         log_surftemp,
         area_ha,
         log_area,
         elev,
         log_elev,
         chla,
         log_chla,
         do_surf,
         log_do,
         bf_max,
         sqrt_bf,
         n2o,
         n2o_eq,
         no3,
         no3_cat
         )

save(df_model, file = "/modelFiles/df_model.rda") 
```

A preview of the `r nrow(df_model)` probability samples to be used in
modeling:

```{r model_data_print, echo=TRUE, paged.print=TRUE}
df_model %>%
  head()
```

A second data frame, including only the second visit observations was
constructed below. These data were later used as a "test set" to assess
the out-of-sample performance of the model developed on the first-visit
or "training set".

```{r test_data, eval=FALSE, include=TRUE}
df_test <- dg %>%
  filter(sample.source == "DG", # dissolved gas info
         sitetype == "PROB") %>% # probability samples only
  filter(visit.no == 2) %>% # second-visit sites only
  mutate(n2o = round(dissolved.n2o.nmol, 2),
         n2o_eq = round(sat.n2o.nmol, 2),
         n2o_sat = n2o.sat.ratio,
         n2o_em = e.n2o.nmol.d,
         n2o_flux = f.n2o.m.d,
         WSA9 = factor(ag.eco9),
         state = factor(state.abb[match(state.nm, state.name)]),
         area_ha = area.ha,
         log_area = log(area_ha),
         chla = chla.result,
         log_chla = log(chla),
         elev = elevation,
         log_elev = log(elev + 1),
         do_surf = o2.surf,
         log_do = log(do_surf),
         bf_max = max.bf,
         sqrt_bf = sqrt(bf_max),
         size_cat = recode(area.cat6, # simpler naming conventions for the size categories
                           "(1,4]" = "min_4" ,
                           "(10,20]" = "10_20",
                           "(20,50]" = "20_50",
                           "(4,10]" = "4_10",
                           ">50" = "50_max")) %>%
  mutate(size_cat = factor(size_cat,
                           levels = c("min_4", "4_10", "10_20", "20_50", "50_max"),
                           ordered = TRUE)) %>%
  mutate(no3 = ifelse(nitrate.n.result <= 0.0005, 0.0005, round(nitrate.n.result, 4))) %>%# 1/2 mdl 0.01
  mutate(no3_cat = cut(log(no3), # convert no3 to ordered factor with 5 levels
                       breaks = c(-Inf, -7.5, -5.5, -3.5, -1.5, Inf),
                       labels =seq(1, 5, 1))) %>%
  mutate(no3_cat = factor(no3_cat,
                          levels = seq(1, 5, 1),
                          ordered = TRUE)) %>%
  mutate(date = as.Date(date.col)) %>%
  mutate(jdate = as.numeric(format(date, "%j"))) %>% 
  mutate(lat = map.lat.dd,
         lon = map.lon.dd) %>% # longitude
  mutate(surftemp = surftemp,
         log_surftemp = log(surftemp)) %>% 
  select(WSA9,
         state,
         size_cat,
         site.id,
         lat,
         lon,
         date,
         jdate,
         surftemp,
         log_surftemp,
         area_ha,
         log_area,
         elev,
         log_elev,
         chla,
         log_chla,
         do_surf,
         log_do,
         bf_max,
         sqrt_bf,
         n2o,
         n2o_eq,
         no3,
         no3_cat
         )

save(df_test, file = "modelFiles/df_test.rda") 
```

A preview of the re-visit data with `r nrow(df_test)` observations:

```{r test_data_print, echo=TRUE, paged.print=TRUE}
df_test %>%
  head()
```

## Target population

Below, the 2017 NLA sampling frame was imported and filtered to include
only lakes in the assumed POI. The resulting target population included
a total of 465,897 waterbodies.

```{r import_sample_frame, eval=FALSE, include=TRUE}
df_pop <- read.csv(archive::archive_read("inputData/NLA_Sample_Frame.7z")) # This takes a bit

sframe <- df_pop %>%
  filter(nla17_sf != "Exclude2017") %>%
  filter(nla17_sf != "Exclude2017_Include2017NH") %>%
  filter(state != "DC") %>%
  filter(state != "HI") %>%
  droplevels() %>%
  mutate(WSA9 = factor(ag_eco9),
         WSA9 = forcats::fct_drop(WSA9), # remove NA level
         state = factor(state),
         size_cat = factor(area_cat6),
         lat = lat_dd83,
         lon = lon_dd83,
         log_area = log(area_ha),
         elev = elevation,
         log_elev = ifelse(elev <= 0, 0, elev), # assumed elev < 0 to be elev = 0
         log_elev = log(log_elev + 1)
         ) %>% 
  mutate(size_cat = recode(size_cat, 
                           "(1,4]" = "min_4" ,
                           "(10,20]" = "10_20",
                           "(20,50]" = "20_50",
                           "(4,10]" = "4_10",
                           ">50" = "50_max")) %>%
  mutate(size_cat = factor(size_cat, 
                           levels = c("min_4", "4_10", "10_20", "20_50", "50_max"),
                           ordered = TRUE)) %>%
  select(WSA9, state, size_cat, lat, lon, area_ha, log_area, elev, log_elev)

rm(df_pop)

save(sframe, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sframe.rda") 
```

Below is a sample of the first ten rows of the POI:

```{r sample_frame_print, echo=TRUE, paged.print=TRUE}
sframe %>%
  head(10)
```

Cross tabulations below show the structure of the target population with
respect to the survey design variables. The cross-tabulation shows that,
of course, each ecoregion does not contain each state. Therefore, states
were nested within ecoregions.

```{r frame_dimensions_1, echo=TRUE, message=FALSE}
sframe %>%
  group_by(WSA9, state) %>%
  summarise(n = n(), .groups = "drop") %>%
  spread(state, n) 
```

The cross-tablulation below indicates that lake size category was nested
within state (which was nested in ecoregion). That is, not every
ecoregion:state contained every size category.

```{r frame_dimensions_4, echo=TRUE, message=FALSE}
sframe %>%
  group_by(WSA9, state, size_cat) %>%
  summarise(n = n(), .groups = "drop") %>%
  spread(size_cat, n) 
```

Below, the sampling frame was used to create a typical
post-stratification table. There were 536 "types" or groupings of lakes
in the POI with respect to the sampling design. The total counts of
those lake types (n_lakes) and their proportions (prop_cell) relative to
the counts in the target population were tabulated.

```{r filter_frame, eval=FALSE, include=TRUE}
pframe <- sframe %>%
  mutate(obs = 1) %>%
  group_by(WSA9, state, size_cat) %>%
  summarise(n_lakes = sum(obs), .groups = "drop") %>%
  ungroup() %>%
  mutate(prop_cell = n_lakes/sum(n_lakes)) %>%
  mutate(type = "population") 

save(pframe, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/pframe.rda")
```

```{r filter_frame_print}
pframe %>%
  head(10)
```

## Sample vs. population

Below, the distribution of waterbody types in the POI were compared to
their proportions in the observed sample. There were 352 waterbody types
in the sample compared to the 536 in the POI. There were 984
observations distributed across these 352 lake types in the sample; and
the number of samples was not distributed evenly across the types. Some
cells were represented by as few as 1 lake. In total, 536-352 = 184 lake
types in the population of interest were not represented in the sample.

```{r sample_cell_counts, eval=FALSE, include=TRUE}
samp_props <- df_model %>%
  mutate(obs = 1) %>%
  group_by(WSA9, state, size_cat) %>%
  summarize(n_lakes = sum(obs), .groups = "drop") %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes / sum(n_lakes), 7)) %>%
  mutate(type = "sample") 

save(samp_props, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/samp_props.rda")
```

```{r sample_cell_count_print, echo=TRUE, paged.print=TRUE}
samp_props %>%
  print(n = 10)
```

Below, a graphical comparison was constructed to depict the distribution
of cells in the POI *vs.* those in the sample.

```{r compare_sample_pop_cells, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10}
pframe %>%
  bind_rows(samp_props) %>%
  ggplot(aes(x = interaction(WSA9, state, size_cat), y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes( shape = type, color = type)) +
  geom_line() +
  theme_tidybayes() +
  theme(axis.text.x = element_blank()) +
  xlab("WSA9:state:size") +
  ylab("proportion in cell")
```

Another comparison between population and sample was constructed by
ecoregion below. Lakes in the Coastal Plains (CPL) ecoregion, for
example, were clearly undersampled relative to their proportion of the
population.

```{r eco_props_pop, fig.align='center', fig.asp=0.5, fig.width=10}
pframe_eco <- pframe %>%
  group_by(WSA9) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'population') 

samp_props_eco <- samp_props %>%
  group_by(WSA9) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'sample')

pframe_eco %>%
  bind_rows(samp_props_eco) %>%
  ggplot(mapping = aes(x = WSA9, y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes( shape = type, color = type), size = 3) +
  geom_line() +
  theme_tidybayes() +
  xlab("Ecoregion") +
  ylab("proportion in cell") + 
  theme(legend.position = "top",
        legend.title = element_blank(),
        legend.text = element_text(size = 14)) +
  theme(text = element_text(size = 12))
```

A similar comparison by state was constructed below.

```{r state_props_pop, fig.align='center', fig.asp=0.5, fig.width=10}
pframe_state <- pframe %>%
  group_by(state) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'population')

samp_props_state <- samp_props %>%
  group_by(state) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'sample')

pframe_state %>%
  bind_rows(samp_props_state) %>%
  ggplot(mapping = aes(x = state, y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes(shape = type, color = type)) +
  geom_line() +
  theme_tidybayes() +
  theme(axis.text.x = element_text(angle = 45)) +
  xlab("State") +
  ylab("proportion in cell")
```

Finally, a comparison by NLA size category is shown below. Waterbodies
of the smallest size category were heavily under-sampled relative to the
POI and those from the larger size categories were over-sampled.

```{r size_props_pop, fig.align='center', fig.asp=0.5, fig.width=10}
pframe_size <- pframe %>%
  group_by(size_cat) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'population')

samp_props_size <- samp_props %>%
  group_by(size_cat) %>%
  summarise(n_lakes = sum(n_lakes)) %>%
  ungroup() %>%
  mutate(prop_cell = round(n_lakes/sum(n_lakes), 7)) %>%
  ungroup() %>%
  mutate(type = 'sample')

pframe_size %>%
  bind_rows(samp_props_size) %>%
  ggplot(mapping = aes(x = size_cat, y = prop_cell, group = type, linetype = type)) +
  geom_point(stat = "identity", aes( shape = type, color = type)) +
  geom_line() +
  theme_tidybayes() +
  xlab("Size category") +
  ylab("proportion in cell")
```

## Sample-based estimates

Below are (naive) estimates, based only on the sample, for national
means for dissolved and equilibrium N2O and the saturation ratio.

Dissolved N2O:

```{r sample_summary_n2o}
df_model %>%
  summarise(mean = mean(n2o),
             sd = sd(n2o)) 
```

Equilibrium N2O:

```{r sample_summary_n2oeq}
df_model %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq))
```

Saturation ratio:

```{r sample_summary_n2osat}
df_model %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) 
```

Roughly 67% of lakes in the sample were under-saturated (i.e.,
saturation ratio \< 1):

```{r sample_summary_propsat}
df_model %>%
  summarise(prop_undersat = sum((n2o / n2o_eq) < 1) / 984) 
```

Using only the sample observations again, a plot was constructed of the
overall mean (dashed line) along with the ecoregion-specific means
(black circles). The shaded areas indicate +/- 1 standard deviation.
Neither dissolved N2O nor the saturation ratio were clearly structured
by ecoregion in the sample, but there did appear to be some potential
structure along this variable in the equilibrium N2O observations.

```{r sample_summary_eco, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  group_by(WSA9) %>%
  summarise(mean = mean(n2o),
             sd = sd( n2o)) %>%
  ggplot(aes(x = WSA9, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = WSA9), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = WSA9, y = mean))+
  geom_point()+
  geom_hline(yintercept = 8.72, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) + 
  ylab("") +
  ggtitle("N2O")

p2 <- df_model %>%
  group_by(WSA9) %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  ggplot(aes(x = WSA9, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = WSA9), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = WSA9, y = mean))+
  geom_point()+
  geom_hline(yintercept = 7.48, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) +
  ylab("Sample mean") +
  ggtitle("N2O equilibrium")

p3 <- df_model %>%
  group_by(WSA9) %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  ggplot(aes(x = WSA9, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = WSA9), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = WSA9, y = mean))+
  geom_point()+
  geom_hline(yintercept = 1.17, linetype = 'dashed') +
  theme_tidybayes() +  
  xlab("Ecoregion") +
  ylab("") +
  ggtitle("N2O saturation ratio")

grid.arrange(p1, p2, p3)
```

The same summary by state is below.

```{r sample_summary_state, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  group_by(state) %>%
  summarise(mean = mean(n2o),
             sd = sd( n2o)) %>%
  ggplot(aes(x = state, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = state), 
              fill = 'lightgrey', 
              alpha = .7) +
  geom_line(aes(x = state, y = mean))+
  geom_point()+
  geom_hline(yintercept = 8.72, linetype = 'dashed') + 
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) + 
  ylab("") +
  ggtitle("N2O")

p2 <- df_model %>%
  group_by(state) %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  ggplot(aes(x = state, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = state), 
              fill = 'lightgrey', 
              alpha = .7) +
  geom_line(aes(x = state, y = mean))+
  geom_point()+
  geom_hline(yintercept = 7.48, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) +
  ylab("Sample mean") +
  ggtitle("N2O equilibrium")

p3 <- df_model %>%
  group_by(state) %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  ggplot(aes(x = state, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = state), 
              fill = 'lightgrey', 
              alpha = .7)+
  geom_line(aes(x = state, y = mean))+
  geom_point()+
  geom_hline(yintercept = 1.17, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.text.x = element_text(angle = 45)) + 
  xlab("State") +
  ylab("") +
  ggtitle("N2O saturation ratio")

grid.arrange(p1, p2, p3)
```

Finally, the same summary by size category.

```{r sample_summary_size, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  group_by(size_cat) %>%
  summarise(mean = mean(n2o),
             sd = sd( n2o)) %>%
  ggplot(aes(x = size_cat, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = size_cat), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = size_cat, y = mean))+
  geom_point()+
  geom_hline(yintercept = 8.72, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) + 
  ylab("") +
  ggtitle("N2O")

p2 <- df_model %>%
  group_by(size_cat) %>%
  summarise(mean = mean(n2o_eq),
             sd = sd(n2o_eq)) %>%
  ggplot(aes(x = size_cat, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = size_cat), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = size_cat, y = mean))+
  geom_point()+
  geom_hline(yintercept = 7.48, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank()) +
  ylab("Sample mean") +
  ggtitle("N2O equilibrium")

p3 <- df_model %>%
  group_by(size_cat) %>%
  summarise(mean = mean(n2o / n2o_eq),
             sd = sd(n2o / n2o_eq)) %>%
  ggplot(aes(x = size_cat, y = mean, group = 1)) +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd, x = size_cat), fill = 'lightgrey', alpha = .7)+
  geom_line(aes(x = size_cat, y = mean))+
  geom_point()+
  geom_hline(yintercept = 1.17, linetype = 'dashed') +
  theme_tidybayes() + 
  theme(axis.text.x = element_text(angle = 45)) + 
  xlab("Size class") +
  ylab("") +
  ggtitle("N2O saturation ratio")

grid.arrange(p1, p2, p3)
```

## Sample data exploration

Below, the distribution N2O concentrations for the sample was summarized
using a density and rug plot. Note the natural log scale of the x-axis.
Both the dissolved and equilibrium N2O data had considerable right skew
even after the log transformation. This was not unexpected and has been
noted in other studies [*e.g.*, @Webb_etal_2019]. The saturation ratio
was also skewed (sat_ratio = n2o / n2o_eq).

```{r summary_N2O, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=10, message=FALSE}
p1 <- df_model %>%
  ggplot(aes(x = n2o)) +
  geom_boxplot(aes(x = n2o, y = -0.5), outlier.shape = NA, alpha = 0.7) + 
  geom_density(aes(x = n2o)) +
  geom_rug(aes(x = n2o), show.legend = F ) +
  theme(text = element_text(size=12)) +
  scale_x_continuous(trans = "log", breaks = c(0, 5, 10, 25, 50, 150)) +
  ylab("density") +
  xlab("N2O (nmol/L)") +
  theme_tidybayes() +
  theme(axis.text.y = element_blank())

p2 <- df_model %>%
  ggplot(aes(x = n2o_eq)) +
  geom_boxplot(aes(x = n2o_eq, y = -0.5), outlier.shape = NA, alpha = 0.7) + 
  geom_density(aes(x = n2o_eq)) +
  geom_rug(aes(x = n2o_eq), show.legend = F ) +
  theme(text = element_text(size=12)) +
  scale_x_continuous(trans = "log") +
  ylab("density") +
  xlab("Equilibrium N2O (nmol/L)") +
  theme_tidybayes() +
  theme(axis.text.y = element_blank())

p3 <- df_model %>%
  ggplot(aes(x = n2o / n2o_eq)) +
  geom_boxplot(aes(x = n2o / n2o_eq, y = -0.5), outlier.shape = NA, alpha = 0.7) + 
  geom_density(aes(x = n2o / n2o_eq)) +
  geom_rug(aes(x = n2o / n2o_eq), show.legend = F ) +
  theme(text = element_text(size=12)) +
  scale_x_continuous(trans = "log", breaks = c(0, 1, 5, 10, 20)) +
  ylab("density") +
  xlab("N2O saturation ratio") +
  theme_tidybayes() +
  theme(axis.text.y = element_blank())

grid.arrange(p1, p2, p3)
```

Below are plots of dissolved N2O vs. NO3 and some other potential
covariates. This first plot shows log(N2O) vs. log(NO3), as well as the
ordinal categories assigned to NO3 (vertical lines). The leftmost
vertical line is dashed and separates the NO3 observations below the
detection limit. The trend is increasing and nonlinear on the log scale,
with increasing variance in N2O as NO3 increased.

```{r summary_N2O_vs_NO3, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  geom_vline(xintercept = -7.5, linetype = "dashed") +
  geom_vline(xintercept = -5.5) +
  geom_vline(xintercept = -3.5) +
  geom_vline(xintercept = -1.5) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

Below is a plot of N2O vs. the surface temperature observations.

```{r summary_N2O_vs_surftemp, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = surftemp, y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

Below are plots of dissolved N2O vs. NO3 for 3 quantiles of the surface
temperature measurements (quantiles increasing from 1 to 3). This plot
suggested that the NO3 effect on N2O may have been stronger in lakes
with higher observed temperatures.

```{r summary_N2O_vs_NO3_surftemp, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(surftemp, 3)), ncol = 1) +
  theme_bw()
```

Below is a plot of N2O vs. the natural log of the surface area data for
each lake from the NHD. The plot doesn't suggest a strong effect, but
the pattern of variation suggests more variability in dissolved N2O in
smaller lakes.

```{r summary_N2O_vs_logarea, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log_area, y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

The next plot below shows the relationship between dissolved N2O and NO3
at 3 different quantiles (increasing 1 to 3) of the log-scaled lake
surface area estimates. This plot perhaps suggests a weaker NO3 effect
in the largest lakes.

```{r summary_N2O_vs_NO3_logarea, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(log_area, 3)), ncol = 1) +
  theme_bw()
```

Below is a plot of N2O vs. the natural log of the dissolved oxygen
measurements. Measurements for DO were missing from 4 samples and these
observations were excluded from the plot below. The plot suggests a
positive effect of DO, but the pattern may be dominated by extreme
values at the upper and lower end of log(DO).

```{r summary_N2O_vs_logDO, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  filter(!is.na(log_do)) %>%
  ggplot(aes(x = log_do, y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

The next plot below shows the relationship between dissolved N2O and NO3
at 3 different quantiles (increasing 1 to 3) of the log-scaled dissolved
oxygen measurements. Measurements for DO were missing from 4 samples and
these observations were excluded from the plot below. This plot doesn't
suggest a clear interaction of DO with NO3.

```{r summary_N2O_vs_NO3_logDO, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  filter(!is.na(log_do)) %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(log_do, 3)), ncol =1) +
  theme_bw()
```

Below is a plot of N2O vs. the natural log of the chlorophyll a
measurements. Measurements were missing from 4 samples and these
observations were excluded from the plot. The plot suggests perhaps a
slight negative effect of chl-a.

```{r summary_N2O_vs_logChla, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  filter(!is.na(log_chla)) %>%
  ggplot(aes(x = log_chla, y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

The next plot below shows the relationship between dissolved N2O and NO3
at 3 different quantiles (increasing 1 to 3) of the log-scaled
chlorophyll a measurements. Measurements for chl-a were missing from 4
samples and these observations were excluded from the plot below. There
is no clear interaction indicated in the plot below, but the NO3 effect
may be stronger at high chl-a levels.

```{r summary_N2O_vs_NO3_logChla, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  filter(!is.na(log_chla)) %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(log_chla, 3)), ncol = 1) +
  theme_bw()
```

Below is a plot of N2O vs. a square root transformation of the bouyancy
factor (BF) metric. Again, measurements were missing from 4 samples and
these observations were excluded from the plot. The plot suggests
perhaps a slight negative effect of the BF metric.

```{r summary_N2O_vs_sqrt_bf, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  filter(!is.na(sqrt_bf)) %>%
  ggplot(aes(x = sqrt_bf, y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

The next plot below shows the relationship between dissolved N2O and NO3
at 3 different quantiles (increasing 1 to 3) of the BF metric. There is
no clear interaction indicated in the plot below.

```{r summary_N2O_vs_NO3_BF_max, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE}
df_model %>%
  filter(!is.na(sqrt_bf)) %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(sqrt_bf, 3)), ncol = 1) +
  theme_bw()
```

Similar plots are below, but with NO3 expressed as an ordered
categorical variable with 5 levels. The positive and monotonic trends
area similar to the previous plots where NO3 was treated as continuous.
Note the large number of observations in the first NO3 category (no3_cat
= 1). This category represented all of the observations for NO3 that
were below the detection limit, which was most of the data.

```{r summary_N2O_vs_NO3cat, echo=FALSE, fig.align='center', fig.asp=0.75, fig.width=5, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(outlier.shape = NA, notch = TRUE, color = "black", alpha = 0.7) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

The plot below is N2O vs NO3 for three quantiles (increasing) of surface
temperature.

```{r summary_N2O_vs_NO3cat_surftemp, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(outlier.shape = NA, color = "black", alpha = 0.7) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(surftemp, 3)), ncol = 1) +
  theme_bw()
```

The plot below is N2O vs NO3 for three quantiles (increasing) of (log)
surface area.

```{r summary_N2O_vs_NO3cat_logarea, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(outlier.shape = NA, color = "black", alpha = 0.7) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ as.factor(ntile(log_area, 3)), ncol = 1) +
  theme_bw()
```

Below is a plot of log(dissolved N2O) vs. log(NO3) by ecoregion, which
suggested that the NO3 effect on dissolved N2O may have varied by
ecoregion.

```{r summary_N2O_vs_NO3_ecoregion, echo=FALSE, fig.align='center', fig.asp = 0.75, fig.width = 8, message=FALSE}
df_model %>%
  ggplot(aes(x = log(no3), y = log(n2o))) +
  geom_point(show.legend = F) +
  geom_smooth(method = "loess", span = 2) +
  geom_vline(xintercept = -7.5, linetype = "dashed") +
  geom_vline(xintercept = -5.5) +
  geom_vline(xintercept = -3.5) +
  geom_vline(xintercept = -1.5) +
  theme(text = element_text(size=12)) +
  facet_wrap(~ WSA9) +
  theme_bw()
```

Below is the same plot as above but for the ordered categorical version
of NO3.

```{r summary_N2O_vs_NO3cat_ecoregion, echo=FALSE, fig.align='center', fig.asp = 0.75, fig.width = 8, message=FALSE}
df_model %>%
  ggplot(aes(x = no3_cat, y = log(n2o), color = 1)) +
  geom_point( position = position_jitterdodge(), show.legend = F ) +
  geom_boxplot(aes(x = no3_cat, y = log(n2o)), 
               outlier.shape = NA, 
               color = "black", 
               alpha = 0.7) + 
  facet_wrap(~ WSA9) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

A plot below shows the relationships between dissolved N2O and log(NO3)
by state, but within just the Temperate Plains (TPL) ecoregion. Within
states, the number of observations were relatively small, but the trends
were perhaps more linear.

```{r summary_N2O_vs_NO3_wsa9state3, echo=FALSE, fig.align='center', fig.asp = 0.75, fig.width = 8, message=FALSE}
df_model %>%
  filter(WSA9 == "TPL") %>%
  ggplot(aes(x = log(no3), y = log(n2o), group = state, color = state)) +
  geom_point(show.legend = F) +
  geom_smooth(method = "lm", span = 2, alpha = 0.1) +
  theme(text = element_text(size=12)) +
  theme_bw()
```

# Model Fitting

## Model 1

The first model for the two N2O responses, conditioned only on the study
design factors.

```{r n2o_mod_mv_1, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ 1 + 
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ 1 + 
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) +
               (1 | c | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"), # centered near data mean
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(exponential(2), class = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), # centered near data mean
  prior(exponential(2), class = "sd", resp = "logn2oeq"),
  prior(exponential(2), class = "sigma", resp = "logn2oeq"),
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod1 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model,
                prior = priors,
                control = list(adapt_delta = 0.99, max_treedepth = 14),
                #sample_prior = "only",
                save_pars = save_pars(all = TRUE),
                seed = 145,
                chains=4, 
                iter=5000, 
                cores=4)

save(n2o_mod1, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod1.rda")
```

### Summarize fit

The summaries of the estimated parameters and key HMC convergence
diagnostics for the fitted model are printed below. There were no
apparent issues with the HMC sampling. All $\hat{R}$ values were less
than 1.01 and effective sample size ($ESS$) calculations suggested that
the posterior contained a sufficient number of effective samples for
conducting inference.

```{r print_mod1, echo=FALSE}
print(n2o_mod1, prior = T)
```

In the summary above, the estimated standard deviations for the varying
group effects on the mean behavior of the dissolved N2O response
suggested fairly low, but non-zero variability across each of the three
levels. The standard deviations estimated for the same varying effects
for equilibrium N2O were also relatively small. Finally, note the
relatively small, but positive residual correlation between the two N2O
responses.

Before investing too much into inferences from this model, however, the
model fit was evaluated below using a series of graphical posterior
predictive checks [PPC, @Gelman_etal_2014; @Gelman_etal_2020, Ch. 11].

### Model checks

#### Dissolved N2O

Below are a series of panels illustrating graphical PPCs for the
dissolved N2O component of the multivariate model. The top left panel
compares a density plot of the observed data (black line) to density
estimates drawn for 200 samples from the posterior predictive
distribution (PPD; blue lines) of the fitted model. The top right panel
compares the cumulative density distributions in the same manner. The
left middle panel compares means *vs.* standard deviations for 1000
draws from the PPD (blue dots) to the sample mean *vs.* standard
deviation (black dot). The right middle panel compares skewness *vs.*
kurtosis for 1000 draws from the PPD to the skewness *vs.* kurtosis
estimates for the observed data. The bottom left panel compares max
*vs.* min values for 1000 draws from the PPD to the max *vs.* min values
of the sample data. Finally, the bottom right panel shows the observed
*vs.* average predicted values for each observation in the sample. The
average predicted values were calculated as the mean prediction for each
observation in the PPD based on 1000 draws.

```{r ppc_n2o1, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2o",
         type = "scatter_avg",
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

The general takeaway from the PPCs above was that the model replicated
the central tendency of the observed data fairly well, but failed to
sufficiently replicate other important aspects of the distribution, such
as skewness and kurtosis. The observed *vs.* average predictions
scatterplot also suggested substantial heteroscedasticity in the errors.

The same checks were run below, but for the test set of 95 held-out,
second-visit data points. The patterns in misfit were similar to the
patterns indicated in the PPCs with the training data above.

```{r ppc_n2o1_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2o",
         type = "scatter_avg",
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

Below are PPCs for the equilibrium N2O component of the model. As with
the dissolved N2O PPCs, the model seemed to do an OK job at replicating
the central tendency, but performed less well at replicating other
important aspects of the overall distribution.

```{r ppc_n2oeq1, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

Below are the same PPCs for equilibrium N2O in the re-visit sites.

```{r ppc_n2oeq1_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod1,
         newdata = df_test,
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod1, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

The graphical check below compared bivariate density contours estimated
from the observed data (black lines) to density contours estimated for
each of 20 draws from the PPD. The model appeared to do a good job of
replicating the bivariate mean, but was poor at representing the overall
joint distribution.

```{r ppc_biv1, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5,  message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 20) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o), y = log(n2o_eq))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

The same bivariate check is shown below for the re-visit data.

```{r ppc_biv1_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 20) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o), y = log(n2o_eq))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

The graphical PPCs below were aimed at evaluating how well the
multivariate model did at representing the observed saturation ratio:

$$\dfrac{N_2O_{diss}} {N_2O_{equi}}$$

This quantity was estimated as a derived variable by dividing the
dissolved N2O PPD by the equilibrium N2O PPD. The proportion of
under-saturated lakes in the sample was estimated by summing the number
of lakes from each posterior predictive draw wherein the ratio was \< 1
and dividing that number by the total number of lakes in the sample,
which was 984. Overall, these checks indicated that properly
representing the tails of the dissolved N2O and N2O-eq observations
would likely be necessary in order to better replicate the observed
saturation metrics. The observed proportion of under-saturated lakes was
underestimated by more than 10 percentage points, on average.

The top left panel, below, is a density plot of the observed saturation
ratio (black line) compared to an estimate using 50 draws from the
derived PPD (blue lines). The top right panel shows the observed
proportion of under-saturated lakes compared to a model estimate based
on 1000 draws from the PPD. The left middle panel shows the mean *vs.*
standard deviation of the saturation ratio for the observed data
compared to the same estimates for 500 draws from the PPD. The right
middle panel shows the max *vs.* min for the sample compared to 500
draws from the PPD. Finally, the bottom left panel shows the observed
*vs.* average predicted saturation ratio for all 984 lakes sampled in
the dataset.

```{r ppc_sat1, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_model)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_model))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The same PPCs are shown below for the revisit data. These checks
indicated that the model did a similarly underwhelming job of
replicating the re-visit data.

```{r ppc_sat1_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_test)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_test))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod1, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

Below, the Bayesian $R^2$ values are reported for each response in the
model.

```{r r2_1, echo=FALSE, message=FALSE, warning=FALSE, cache = TRUE}
round(bayes_R2(n2o_mod1, resp = "logn2o", cores = 1), 3)
round(bayes_R2(n2o_mod1, resp = "logn2oeq", cores = 1), 3)
```

The $R^2$ were also estimated for the re-visit data.

```{r r2_1_test, echo=FALSE, message=FALSE, warning=FALSE, cache = TRUE}
round(bayes_R2(n2o_mod1, resp = "logn2o", newdata = df_test, cores = 1), 3)
round(bayes_R2(n2o_mod1, resp = "logn2oeq", newdata = df_test, cores = 1), 3)
```

## Model 2

In an attempt to better fit the observed data, the next model included a
distributional sub-model that allowed for heterogeneous variances. The
distributional terms for both N2O responses were each fit as a function
of the survey design structure. The same structure as for the models for
the submodels for the mean component before.

```{r n2o_mod_2, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ 1 +
               (1 | a | WSA9) + 
               (1 | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ 1 +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod2 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 84512,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod2, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod2.rda")
```

### Summarize fit

The summaries of the estimated parameters and key HMC convergence
diagnostics for the fitted model are printed below.

```{r print_mod2, echo=FALSE}
print(n2o_mod2, prior = T)
```

### Model checks

Below the same PPCs were performed as with the initial model (see above
for more details on each panel). Though the checks below suggested some
improvement in replicating the tails of the observed data, the overall
fit again suggested room for improvement.

##### Dissolved N2O

```{r ppc_n2o2, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(-5, 5) +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(-5, 5) +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2o",
         type = "scatter_avg", 
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

The same check is below for the 95 re-visit sites.

```{r ppc_n2o2_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(-5, 5) +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(-5, 5) +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2o",
         type = "scatter_avg", 
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The checks below suggested that this model offered little improvement
upon the initial model for equilibrium N2O.

```{r ppc_n2oeq2, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

The same check with the re-visit data is below.

```{r ppc_n2oeq2_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod2, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "scatter_avg", 
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

This check perhaps suggested an improvement with regard to replicating
the joint density. However, the predictions were still clearly
over-dispersed relative to the observations.

```{r ppc_biv2, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

The same check with the re-visit data is below.

```{r ppc_biv2_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

The PPCs for the saturation metrics below indicated that including the
distributional models was perhaps an improvement on the initial model in
some aspects; in particular, the bias in the predicted proportion of
under-saturated lakes was substantially decreased. However, there
appeared to still be issues in replicating the tails as well as issues
with central tendency.

```{r ppc_sat2, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_model)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_model))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The check for the revisit data is below.

```{r ppc_sat2_revisit, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(logn2o < logn2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_test)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_test))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod2, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

Relative to model 1, there was a substantial decrease in the $R^2$
estimate for the dissolved N2O component of this model. The estimate for
the equilibrium N2O-eq component was similar to model 1.

```{r r2_2, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod2, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod2, resp = "logn2oeq", cores = 1), 3)
```

And for the re-visit data:

```{r r2_2_test, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod2, resp = "logn2o", newdata = df_test, cores = 1), 3) 
round(bayes_R2(n2o_mod2, resp = "logn2oeq", newdata = df_test, cores = 1), 3)
```

## Model 3

In the next model, the categorical version of the NO3 covariate and a
surface temperature covariate were included to try to improve the fit.
The ordinal NO3 variable was used as a monotonic, ordinal effect and
only in the dissolved N2O component of the model. For the equlibrium N2O
component, surface temperature and log-transformed elevation were used,
along with their interaction. The model also retained the same
distributional specifications included in model 2 above.

```{r n2o_mod_3, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ mo(no3_cat) +
               surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ 1 +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(normal(0, 1), class = "b", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(normal(0, 1), class = "b", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"), 
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod3 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 98456,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod3, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod3.rda")
```

### Summarize fit

The fitted parameters and MCMC diagnostics are below.

```{r print_mod3, echo=FALSE}
print(n2o_mod3, prior = T)
```

### Model checks

#### Dissolved N2O

The PPCs below indicated a better fit compared to the previous models.
The central tendency and tail behavior looked to be reasonably
replicated by comparison. However, the observed *vs.* predicted plot
suggested that larger N2O observations were likely being systematically
underestimated.

```{r ppc_full_checks_mod_n2o3, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(0, 5) +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(0, 5) +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2o",
         type = "scatter_avg",  
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

Below are the same PPCs for the second-visit data.

```{r ppc_full_checks_mod_n2o3_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2o",
         type = "dens_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(0, 5) +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2o",
         type = "ecdf_overlay",
         ndraws = 200) + 
  theme_tidybayes() +
  xlim(0, 5) +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2o",
         type = "scatter_avg",  
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The PPCs below indicated that this model appeared to be an improvement
for equilibrium N2O as well. However, some checks (e.g., skewness)
suggested some room for additional improvement.

```{r ppc_full_checks_mod_n2oeq3, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "dens_overlay", 
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "ecdf_overlay", 
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         resp = "logn2oeq",
         type = "scatter_avg",  
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

Checks for the 2nd visit data are below.

```{r ppc_full_checks_mod_n2oeq3_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "dens_overlay", 
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "ecdf_overlay", 
         ndraws = 200) + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max"),  
         ndraws = 1000) + 
  theme_tidybayes()
,
pp_check(n2o_mod3, 
         newdata = df_test,
         resp = "logn2oeq",
         type = "scatter_avg",  
         ndraws = 1000) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

The check for the joint distribution below also suggested an improvement
upon the previous models.

```{r ppc_bv_check_mod_n2o3, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

The same check below for the second-visit sites.

```{r ppc_bv_check_mod_n2o3_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

This model looked to be an improvement with regard to the PPCs for the
saturation metrics. However, the proportion of under-saturated lakes
remained biased low and other checks indicated that further improvements
would be ideal.

```{r ppc_sat_check_mod_n2o3, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_model)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_model))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The same check for the second-visit sites are next.

```{r ppc_sat_check_mod_n2o3_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=10,  message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_test)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_test))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod3, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

The $R^2$ estimates for this model are below and suggested substantial
improvements over the previous models.

```{r r2_mod_n2o3, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod3, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod3, resp = "logn2oeq", cores = 1), 3)
```

Next, $R^2$ for the 2nd visit sites.

```{r r2_mod_n2o3_test, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod3, newdata = df_test, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod3, newdata = df_test, resp = "logn2oeq", cores = 1), 3)
```

### Covariate effects

Below are plots illustrating the modeled effects of covariates on both
N2O and equilibrium N2O.

#### Dissolved N2O

The conditional effects plots below for dissolved N2O illustrated a
positive, monotonic, and non-linear relationship with NO3; and a
negative, linear relationship with surface temperature.

```{r conditional_effects_mod_n2o3, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod3, 
                          resp = "logn2o", 
                          effects = c("no3_cat"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod3, 
                          resp = "logn2o", 
                          effects = c("surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
          plot(p2, plot = F)[[1]],
          ncol = 2)

rm(p1, p2)

annotate_figure(plt, top = text_grob("Conditional effects: N2O", 
               color = "black", face = "bold", size = 14))
```

#### Equilibrium N2O

The modeled effects for the equilibrium N2O component illustrated a
negative relationship with both predictors and an interaction such that
the surface temperature effect became slightly steeper at lower
elevations.

```{r conditional_effects_mod_n2oeq3, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod3, 
                          resp = "logn2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod3, 
                          resp = "logn2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob("Conditional effects: Equilibrium N2O", 
               color = "black", face = "bold", size = 14))
```

## Model 4

In the next model, covariate terms were also included in the $\sigma$
components of both models in order to try to better capture remaining
heterogeneity in the variances of both N2O and N2O-eq.

```{r n2o_mod_mv_4, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ mo(no3_cat) +
               surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ mo(no3_cat) +
               surftemp +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(normal(0, 1), class = "b", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(normal(0, 1), class = "b", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"), 
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod4 <- brm(bf_n2o + bf_n2oeq + set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 15851,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod4, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod4.rda")
```

### Summarize fit

Below is a summary of the fitted parameters along with some convergence
diagnostics.

```{r print_mod4, echo=FALSE}
print(n2o_mod4, prior = T, digits = 3)
```

### Model checks

The same PPCs were employed for this model as above.

#### Dissolved N2O

This model appeared to be a moderate improvement on the previous models.

```{r ppc_full_checks_mod_n2o4, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2o",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2o",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         resp = "logn2o",
         type = "scatter_avg") + 
  theme_tidybayes()
, ncol = 2)
```

This same checks for the 2nd visit sites is below.

```{r ppc_full_checks_mod_n2o4_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2o",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2o",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         newdata = df_test,
         resp = "logn2o",
         type = "scatter_avg") + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

This component of the model also seemed to be an improvement over model
3, with better representation in the tails as indicated in the skewness
*vs.* kurtosis PPC.

```{r ppc_full_checks_mod_n2oeq4, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod4, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "scatter_avg") + 
  theme_tidybayes()
, ncol = 2)
```

For the 2nd visit sites.

```{r ppc_full_checks_mod_n2oeq4_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod4,
         newdata = df_test,
         ndraws = 200,
         resp = "logn2oeq",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("density")
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2oeq",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O)"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod4, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "scatter_avg") + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

Again, an improvement over the previous model with a tighter fit of the
PPC to the observed bivariate density.

```{r ppc_bv_check_mod_n2o4, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

For the 2nd visit sites.

```{r ppc_bv_check_mod_n2o4_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

This check also suggested an improvement over the previous models, with
better tail behavior and less bias in the proportion under-saturated
measure.

```{r ppc_sat_check_mod_n2o4, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_model)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_model))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

For the second visit sites:

```{r ppc_sat_check_mod_n2o4_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_test)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_test))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod4, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

The Bayesian $R^2$ estimates below indicated an improvement from the
previous models.

```{r r2_mod_n2o4, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod4, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod4, resp = "logn2oeq", cores = 1), 3)
```

For the 2nd visit data.

```{r r2_mod_n2o4_test, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod4, newdata = df_test, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod4, newdata = df_test, resp = "logn2oeq", cores = 1), 3)
```

### Covariate effects

#### Dissolved N2O

The conditional effects plots for the covariate effects on dissolved N2O
remained similar to the previous model.

```{r conditional_effects_mod_n2o4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o", 
                          effects = c("no3_cat"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o", 
                          effects = c("surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
          plot(p2, plot = F)[[1]],
          ncol = 2)

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": N2O")), 
               color = "black", face = "bold", size = 14))
```

Below are estimates of the conditional effects of the covariates on
$\sigma$ for N2O. These plots suggested a large effect of NO3 on the
variance of N2O, but little to no effect of surface temperature.

```{r conditional_effects_sigma_n2o4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("no3_cat"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, 
                top = text_grob(expression(paste("Covariate effects on ", sigma, ": N2O")),
                                color = "black",
                                face = "bold",
                                size = 14))
```

#### Equilibrium N2O

The covariate effects on equilibrium N2O remained largely the same as
for the previous model.

```{r conditional_effects_mod_n2oeq4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)
plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

The covariate effects on $\sigma$ for N2O-eq suggested a negative effect
of surface temperature and litte to no effect of elevation.

```{r conditional_effects_sigma_n2oeq4, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("surftemp"), 
                          plot = F)
p2 <- conditional_effects(n2o_mod4, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("log_elev"), 
                          plot = F)
plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", sigma, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

## Model 5

In the next model, additional complexity is added to the dissolved N2O
component by including a covariate for continuous lake surface area (log
scale) as well as interactions between NO3 and log(surface area) and
surface temperature. Although some variation due to lake size was likely
captured by the categorical survey variable for size in the models
above, the categorical distinction may not well represent the true
continuous nature of waterbody size and its effects on the response. For
example, the largest size category represented all lakes \>50 hecatares,
which included an extremely wide range of waterbody sizes ranging from
50 to over 300,000 hectares at max. Including the continuous size
covariate at the observation level in this manner was expected to do a
better job of resolving trends with size. Colinearity between the
grouped and observation-level measures were not a major, concern, since
the observation-level measure would account for any variation first.
Though not presented in this document, violations of the Gauss-Markov
assumptions were checked by looking for potential correlations between
model errors and the covariates [@Bafumi_Gelman_2007].

```{r n2o_mod_mv_5, eval=FALSE, include=TRUE}
bf_n2o <- bf(log(n2o) ~ mo(no3_cat) +
               log_area +
               surftemp + 
               mo(no3_cat):log_area +
               mo(no3_cat):surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             sigma ~ log_area +
               mo(no3_cat) +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat), 
             family = gaussian())

bf_n2oeq <- bf(log(n2o_eq) ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             sigma ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = gaussian())

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "logn2o"),
  prior(normal(0, 1), class = "b", resp = "logn2o"),
  prior(exponential(2), class = "sd", resp = "logn2o"),
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2o"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2o"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2o"),
  
  prior(normal(2, 1), class = "Intercept", resp = "logn2oeq"), 
  prior(normal(0, 1), class = "b", resp = "logn2oeq"), 
  prior(exponential(2), class = "sd", resp = "logn2oeq"), 
  prior(normal(-1, 2), class = "Intercept", dpar = "sigma", resp = "logn2oeq"),
  prior(normal(0, 1), class = "b", dpar = "sigma", resp = "logn2oeq"),
  prior(exponential(2), class = "sd", dpar = "sigma", resp = "logn2oeq"),
  
  prior(lkj(2), class = "rescor"),
  prior(lkj(2), class = "cor")
  )

n2o_mod5 <- brm(bf_n2o + 
                  bf_n2oeq +
                  set_rescor(rescor = TRUE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 12),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 54741,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod5, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod5.rda")
```

### Summarize fit

Below is a summary of the fitted parameters along with MCMC convergence
diagnostics.

```{r print_mod5, echo=FALSE}
print(n2o_mod5, prior = T, digits = 3)
```

### Model checks

Again, the same PPCs as above were performed for this model.

#### Dissolved N2O

The PPC for dissolved N2O below suggested minimal improvements upon the
the previous model.

```{r ppc_full_checks_mod_n2o5, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2o",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2o",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2o",
         type = "scatter_avg", 
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

The same check for the 2nd visit data is below.

```{r ppc_full_checks_mod_n2o5_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2o",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2o",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2o",
         type = "scatter_avg") + 
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The PPCs for this model were similar to the previous model, which was
unsurprising given that it was the same model for N2O-eq.

```{r ppc_full_checks_mod_n2oeq5, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod5, 
         ndraws = 200,
         resp = "logn2oeq",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         ndraws = 1000,
         resp = "logn2oeq",
         type = "scatter_avg") + 
  theme_tidybayes()
, ncol = 2)
```

Below, is the same check using the 2nd visit data.

```{r ppc_full_checks_mod_n2oeq5_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2oeq",
         type = "dens_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 200,
         resp = "logn2oeq",
         type = "ecdf_overlay") + 
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness")) +
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "stat_2d", 
         stat = c("min", "max")) + 
  theme_tidybayes()
,
pp_check(n2o_mod5, 
         newdata = df_test,
         ndraws = 1000,
         resp = "logn2oeq",
         type = "scatter_avg", 
         cores = 1) + 
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

This PPC was also similar to the previous model.

```{r ppc_bv_check_mod_n2o5, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

And the check with the 2nd visit data.

```{r ppc_bv_check_mod_n2o5_test, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = logn2o, 
                      y = logn2oeq, 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

This check was also similar to the prevoius model, with perhaps slightly
less bias in the proportion unsaturated estimates. There was also a
potentially concerning extreme prediction in the observed *vs* predicted
PPC.

```{r ppc_sat_check_mod_n2o5, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_model)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_model))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The same check for the revisit sites below:

```{r ppc_sat_check_mod_n2o5_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(exp(logn2o) < exp(logn2oeq), 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_test)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_test))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod5, 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = exp(logn2o) / exp(logn2oeq)) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

```{r r2_mod_n2o5, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod5, resp = "logn2o", cores = 1), 3) 
round(bayes_R2(n2o_mod5, resp = "logn2oeq", cores = 1), 3)
```

For the revisit sites:

```{r r2_mod_n2o5_test, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod5, resp = "logn2o", newdata = df_test, cores = 1), 3) 
round(bayes_R2(n2o_mod5, resp = "logn2oeq", newdata = df_test, cores = 1), 3)
```

### Covariate effects

#### Dissolved N2O

The conditional effects plots suggested a similar effect of NO3, but
interesting interactions between NO3 and lake area and NO3 and surface
temperature. For lake area, the effect was estimated to be larger and
more negative at the highest levels of NO3; and slightly negative at the
lowest level of NO3. For surface temperature, the effect was estimated
to be largest and positive at the highest level of NO3; and negative at
the lowest level of NO3.

```{r conditional_effects_mod_n2o5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o", 
                          effects = c("no3_cat"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o", 
                          effects = c("log_area:no3_cat"), 
                          plot = F)
p3 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o", 
                          effects = c("surftemp:no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
                 plot(p2, plot = F)[[1]],
                 plot(p3, plot = F)[[1]])

rm(p1, p2, p3)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": N2O")), 
               color = "black", face = "bold", size = 14))
```

The estimated covariate effects on $\sigma$ suggested a negative
relationship with log(area) and a positive relationship, again, with
NO3.

```{r conditional_effects_sigma_n2o5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("log_area"),
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2o",
                          dpar = "sigma",
                          effects = c("no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, 
                top = text_grob(expression(paste("Covariate effects on ", sigma, ": N2O")),
                                color = "black",
                                face = "bold",
                                size = 14))
```

#### Equilibrium N2O

The estimated covariate effects on equilibrium N2O remained largely the
same as estimated in the previous model.

```{r conditional_effects_mod_n2oeq5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

```{r conditional_effects_sigma_n2oeq5, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("surftemp"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod5, 
                          resp = "logn2oeq",
                          dpar = "sigma",
                          effects = c("log_elev"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", sigma, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

## A Final Model

As demonstrated above, models excluding the NO3 covariate consistently
resulted in poorer fits to to the observed dissolved N2O data and
potentially biased estimates of the saturation ratio. Including surface
temperature and elevation in the equilibrium N2O part of the model also
resulted in substantially improved replication of key aspects of the
observed data. Added flexibility in the distributional terms for both
dissolved and equilibrium N2O also led to improvements. To make
inferences to the population of interest from a model including these
covariates, however, they needed to be (1) fully observed across that
population or (2) their missingness needed to be modeled. For the lake
area and elevation covariates, data *was* available for all lakes from
previously compiled geospatial databases. However, neither surface
temperature or NO3 were observed for lakes outside of the sample.
Therefore, the final model below included surface temperature and NO3 as
additional responses conditioned on the survey design variables and
fully observed covariates.

In the final model below, the sub-model for surface temperature assumed
a Gamma distributed error distribution and the linear predictor included
the survey design variables, latitude, elevation, and Julian date. The
shape parameter was also modeled as a function of latitude to address
increasing response variance along the latitudinal gradient. The NO3
response was modeled with a cumulative logit likelihood and the linear
predictor included all of the survey factors as well as surface
temperature and lake area. The dissolved and equilibrium N2O responses
were each modeled with Gamma distributed errors, but with the same
covariate structure as in model 5. The same structure was also employed
for the shape terms in these responses, corresponding to the $\sigma$
terms in the previous models. Note that there was no observation-level
residual correlation term for this model, since the residuals are
undefined for the Gamma and cumulative logit models. Dropping the
observation-level residual correlation term was deemed a reasonable
compromise that enabled the inclusion of NO3 and surface temperature in
the N2O model response. The random intercepts for the group terms,
however, still allowed for potential correlations between responses at
the group levels.

```{r n2o_mod_mv_6, eval=FALSE, include=TRUE}
bf_n2o <- bf(n2o ~ mo(no3_cat) +
               log_area +
               surftemp + 
               mo(no3_cat):log_area +
               mo(no3_cat):surftemp +
               (mo(no3_cat) | a | WSA9) + 
               (mo(no3_cat) | b | WSA9:state) + 
               (1 | c | WSA9:state:size_cat),
             shape ~ log_area +
               mo(no3_cat) +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = Gamma(link = "log"))

bf_n2oeq <- bf(n2o_eq ~ surftemp +
                 log_elev +
                 surftemp:log_elev +
                 (1 | a | WSA9) + 
                 (1 | b | WSA9:state) +
                 (1 | c | WSA9:state:size_cat),
             shape ~ surftemp +
               log_elev +
               (1 | WSA9) + 
               (1 | WSA9:state) + 
               (1 | WSA9:state:size_cat),
             family = Gamma(link = "log"))

bf_temp <- bf(surftemp ~ lat +
                s(log_elev) +
                s(jdate) +
                (1 | a | WSA9) + 
                (1 | b | WSA9:state) +
                (1 | c | WSA9:state:size_cat),
              shape ~ lat,
              family = Gamma(link = "log"))

bf_no3 <- bf(no3_cat ~ surftemp +
               log_area +
               (1 | a | WSA9) +
               (1 | b | WSA9:state) +
               (1 | c | WSA9:state:size_cat),
             family = cumulative(link = "logit", threshold="flexible"))

priors <- c(
  prior(normal(2, 1), class = "Intercept", resp = "n2o"),
  prior(normal(0, 1), class = "b", resp = "n2o"),
  prior(exponential(2), class = "sd", resp = "n2o"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "n2o"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "n2o"),
  prior(exponential(2), class = "sd", dpar = "shape", resp = "n2o"),
  
  prior(normal(2, 1), class = "Intercept", resp = "n2oeq"), 
  prior(normal(0, 1), class = "b", resp = "n2oeq"),  
  prior(exponential(2), class = "sd", resp = "n2oeq"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "n2oeq"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "n2oeq"),
  prior(exponential(2), class = "sd", dpar = "shape", resp = "n2oeq"),
  
  prior(normal(3, 1), class = "Intercept", resp = "surftemp"), 
  prior(normal(0, 1), class = "b", resp = "surftemp"), 
  prior(exponential(0.5), class = "sds", resp = "surftemp"),
  prior(exponential(2), class = "sd", resp = "surftemp"),
  prior(normal(5, 4), class = "Intercept", dpar = "shape", resp = "surftemp"),
  prior(normal(0, 1), class = "b", dpar = "shape", resp = "surftemp"),
  
  prior(normal(0, 3), class = "Intercept", resp = "no3cat"),
  prior(normal(0, 1), class = "b", resp = "no3cat"),
  prior(exponential(1), class = "sd", resp = "no3cat"),
  
  prior(lkj(2), class = "cor")
  )

n2o_mod6 <- brm(bf_n2o + 
                  bf_n2oeq + 
                  bf_temp + 
                  bf_no3 + 
                  set_rescor(rescor = FALSE),
                data = df_model, 
                prior = priors,
  control = list(adapt_delta = 0.975, max_treedepth = 14),
  #sample_prior = "only",
  save_pars = save_pars(all = TRUE),
  seed = 85132,#14548,
  #init = my_inits,
  init_r = 0.5,
  chains=4, 
  iter=5000, 
  cores=4)

save(n2o_mod6, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod6.rda")
```

### Summarize fit

Below is a summary of the fitted parameters and MCMC diagnostics.

```{r print_mod6, echo=FALSE}
print(n2o_mod6, digits = 3, prior = T)
```

### Model checks

Below, the same PPCs for dissolved and equilibrium N2O were used as
before.

#### Dissolved N2O

The PPCs for dissolved N2O were similar to those for models 4 and 5
above.

```{r ppc_full_checks_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod6, 
         ndraws = 200,
         resp = "n2o",
         type = "dens_overlay",
         cores = 1) + 
  theme_tidybayes() +
  scale_x_continuous(trans = "log") +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod6, 
         ndraws = 200, 
         resp = "n2o",
         type = "ecdf_overlay",
         cores = 1) + 
  theme_tidybayes() +
  scale_x_continuous(trans = "log") +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2o",
         type = "scatter_avg", 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
, ncol = 2)
```

The same check for the re-visit data:

```{r ppc_full_checks_mod_n2o6_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod6,
         newdata = df_test,
         ndraws = 200,
         resp = "n2o",
         type = "dens_overlay",
         cores = 1) + 
  theme_tidybayes() +
  scale_x_continuous(trans = "log") +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod6, 
         ndraws = df_test,
         nsamples = 200, 
         resp = "n2o",
         type = "ecdf_overlay",
         cores = 1) + 
  theme_tidybayes() +
  scale_x_continuous(trans = "log") +
  xlab(expression(paste("log(N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod6, 
         newdata = df_test,
         ndraws = 1000,
         resp = "n2o",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         newdata = df_test,
         ndraws = 1000,
         resp = "n2o",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         newdata = df_test,
         ndraws = 1000,
         resp = "n2o",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         newdata = df_test,
         ndraws = 1000,
         resp = "n2o",
         type = "scatter_avg", 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
, ncol = 2)
```

#### Equilibrium N2O

The PPCs for eqilibrium N2O were also similar to the same checks in
models 4 and 5.

```{r ppc_full_checks_mod_n2oeq6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod6, 
         ndraws = 200,
         resp = "n2oeq",
         type = "dens_overlay",
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod6, 
         ndraws = 200,
         resp = "n2oeq",
         type = "ecdf_overlay",
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         resp = "n2oeq",
         type = "scatter_avg", 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
, ncol = 2)
```

The same check with the re-visit data:

```{r ppc_full_checks_mod_n2oeq6_test, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
pp_check(n2o_mod6, 
         ndraws = 200,
         newdata = df_test,
         resp = "n2oeq",
         type = "dens_overlay",
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("density")
,
pp_check(n2o_mod6, 
         ndraws = 200,
         newdata = df_test,
         resp = "n2oeq",
         type = "ecdf_overlay",
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  theme_tidybayes() +
  xlab(expression(paste("log(Equilibrium N"[2],"O) concentration"))) + 
  ylab("cumulative density")
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         newdata = df_test,
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("mean", "sd"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         newdata = df_test,
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("kurtosis", "skewness"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         newdata = df_test,
         resp = "n2oeq",
         type = "stat_2d", 
         stat = c("min", "max"), 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
,
pp_check(n2o_mod6, 
         ndraws = 1000,
         newdata = df_test,
         resp = "n2oeq",
         type = "scatter_avg", 
         cores = 1) + 
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  theme_tidybayes()
, ncol = 2)
```

#### Bivariate

This final model provided a reasonable representation of the bivariate
relationship between the two N2O responses.

```{r ppc_bv_check_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_model %>%
  add_predicted_draws(n2o_mod6,
                      resp = c("n2o","n2oeq"),
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = log(n2o), 
                      y = log(n2oeq), 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

The check with the re-visit data:

```{r ppc_bv_check_mod_n2o6_revisit, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
df_test %>%
  add_predicted_draws(n2o_mod6,
                      resp = c("n2o","n2oeq"),
                      ndraws = 20) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  ggplot(aes(x = log(n2o_obs), y = log(n2oeq_obs))) +
  geom_density_2d(aes(x = log(n2o), 
                      y = log(n2oeq), 
                      group = .draw),
                  bins = 10,
                  color = "lightblue", 
                  alpha = 0.4) +
  geom_density_2d(color = "black", bins = 10) +
  xlim(1.25, 2.75) +
  ylim(1.25, 2.75) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
```

#### Saturation

The saturation ratio PPCs below suggested similar behavior as with
models 4 and 5 above, but with perhaps slightly less bias in the
predictions for the proportion of undersaturated waterbodies and fewer
extreme predictions for the means and standard deviations. The observed
*vs.* predicted PPC also appears to have a better behaved variance and
no extreme predictions, compared to models 4 and 5.

```{r ppc_sat_check_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"),
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(n2o < n2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_model)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_model, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_model))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  theme_tidybayes()
,
df_model %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

The check for the second-vist data:

```{r ppc_sat_check_testdata_mod_n2o6, echo=FALSE, fig.align='center', fig.asp=1.25, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
grid.arrange(
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"),
                      ndraws = 200) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  ggplot(aes(x = sat_ratio)) +
  geom_density(aes(x = sat_pred, group = .draw), 
               n = 1024, 
               adjust = 1,
               color = "lightblue") +
  geom_density(n = 1024, adjust = 2) +
  xlim(0, 5) +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(usat_pred = ifelse(n2o < n2oeq, 1, 0)) %>%
  group_by(.draw) %>%
  summarise(prop_pred = sum(usat_pred) / nrow(df_test)) %>%
  ggplot(aes(x = prop_pred)) +
  geom_histogram(binwidth = 0.001, fill = "lightblue") +
  geom_vline(data = df_test, mapping = aes(xintercept = sum(n2o < n2o_eq)/nrow(df_test))) +
  xlab("Proportion undersaturated waterbodies") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(mean_yrep = mean(sat_pred),
         sd_yrep = sd(sat_pred)) %>% 
  ungroup() %>%
  mutate(mean_y = mean(sat_ratio),
         sd_y = sd(sat_ratio)) %>%
  ggplot(aes(x = mean_yrep, y = sd_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = mean_y), linetype = "dashed") +
  geom_hline(aes(yintercept = sd_y), linetype = "dashed") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.draw) %>%
  mutate(min_yrep = min(sat_pred),
         max_yrep = max(sat_pred)) %>% 
  ungroup() %>%
  mutate(min_y = min(sat_ratio),
         max_y = max(sat_ratio)) %>%
  ggplot(aes(x = min_yrep, y = max_yrep)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_vline(aes(xintercept = min_y), linetype = "dashed") +
  geom_hline(aes(yintercept = max_y), linetype = "dashed") +
  theme_tidybayes()
,
df_test %>%
  add_predicted_draws(n2o_mod6, 
                      resp = c("n2o", "n2oeq"), 
                      ndraws = 1000) %>%
  rename(n2o_obs = n2o,
         n2oeq_obs = n2o_eq) %>%
  tidyr::pivot_wider(names_from = .category,
              values_from = .prediction) %>%
  mutate(sat_ratio = n2o_obs / n2oeq_obs,
         sat_pred = n2o / n2oeq) %>%
  group_by(.row) %>%
  mutate(mean_yrep = mean(sat_pred)) %>% 
  filter(.draw == 1) %>% 
  ggplot(aes(x = mean_yrep, y = sat_ratio)) +
  geom_point(color = "lightblue") +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_tidybayes()
, ncol = 2)
```

#### R-square

Below are estimates for the Bayesian $R^2$, which were largely similar
for the N2O responses as with models 4 and 5 above. The $R^2$ for the
surface temperature response also suggested a good fit.

```{r r2_mod_n2o6, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod6, resp = "n2o"), 3) 
round(bayes_R2(n2o_mod6, resp = "n2oeq"), 3)
round(bayes_R2(n2o_mod6, resp = "surftemp"), 3)
```

Below are the $R^2$ estimates for the second-visit data. That these
estimates were similar to those for the data used to fit the model was
encouraging and suggested that the model may perform reasonably well
out-of-sample.

```{r r2_test_mod_n2o6, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
round(bayes_R2(n2o_mod6, resp = "n2o", newdata = df_test), 3) 
round(bayes_R2(n2o_mod6, resp = "n2oeq", newdata = df_test), 3)
round(bayes_R2(n2o_mod6, resp = "surftemp", newdata = df_test), 3)
```

### Covariate effects

#### Dissolved N2O

The conditional effects plot for the covariate effects on dissolved N2O
suggested a similar effect of NO3 as in previous models, but with
interesting potential interactions between NO3 and lake area and NO3 and
surface temperature. The lake area effect was estimated to be larger and
more negative at the highest levels of NO3 and slightly negative at the
lowest level of NO3. The surface temperature effect was estimated to be
largest and positive at the highest level of NO3 and negative at the
lowest level of NO3.

```{r conditional_effects_mod_n2oF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("no3_cat:log_area"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("log_area:no3_cat"), 
                          plot = F)

p3 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("no3_cat:surftemp"), 
                          plot = F)

p4 <- conditional_effects(n2o_mod6, 
                          resp = "n2o", 
                          effects = c("surftemp:no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]], 
                 plot(p2, plot = F)[[1]],
                 plot(p3, plot = F)[[1]],
                 plot(p4, plot = F)[[1]])

rm(p1, p2, p3, p4)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": N2O")), 
               color = "black", face = "bold", size = 14))
```

The estimated covariate effects on $\sigma$ for dissolved N2O suggested
a negative relationship with log(area) and a positive relationship with
NO3.

```{r conditional_effects_sigma_n2oF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2o",
                          dpar = "shape",
                          effects = c("log_area"),
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2o",
                          dpar = "shape",
                          effects = c("no3_cat"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, 
                top = text_grob(expression(paste("Covariate effects on ", shape, ": N2O")),
                                color = "black",
                                face = "bold",
                                size = 14))
```

#### Equilibrium N2O

The estimated covariate effects on equilibrium N2O remained largely the
same as estimated in the previous model.

```{r conditional_effects_mod_n2oeqF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq", 
                          effects = c("surftemp:log_elev"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq", 
                          effects = c("log_elev:surftemp"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", mu, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

```{r conditional_effects_sigma_n2oeqF, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, cache=TRUE}
p1 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq",
                          dpar = "shape",
                          effects = c("surftemp"), 
                          plot = F)

p2 <- conditional_effects(n2o_mod6, 
                          resp = "n2oeq",
                          dpar = "shape",
                          effects = c("log_elev"), 
                          plot = F)

plt <- ggarrange(plot(p1, plot = F)[[1]],
                 plot(p2, plot = F)[[1]])

rm(p1, p2)

annotate_figure(plt, top = text_grob(expression(paste("Covariate effects on ", shape, ": Equilibrium N2O")), 
               color = "black", face = "bold", size = 14))
```

#### Saturation ratio

Below are the estimated conditional effects of the covariates on means
for both n2o responses as well as the implied effects on the mean
saturation ratio.

```{r conditional_effects_mod_n2osat_temp_F, echo=FALSE, message=FALSE, warning=FALSE, cache.lazy=FALSE}
effect_no3_surftemp <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               surftemp = round(quantile(df_model$surftemp, 
                                                   probs = seq(0.10, 0.90, 0.2)), 0),
                               log_area = mean(df_model$log_area),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         surftemp = factor(surftemp))

effect_surftemp_no3 <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               surftemp = seq(range(df_model$surftemp)[1],
                                              range(df_model$surftemp)[2],
                                              length.out = 101),
                               log_area = mean(df_model$log_area),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         temp = surftemp)

plt_n2oeq_surftemp <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = n2oeq_pred),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Equilibrium N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 20), breaks = seq(0, 20, 5)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Greys", guide = "none")


plt_n2o_surftemp_no3 <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Dissolved N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(axis.text.x = element_blank(),
        legend.position = "none")

plt_n2o_no3_surftemp <-
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab("") +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

plt_sat_no3_surftemp <-
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = sat_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab(expression(paste("NO"[3], " category"))) +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  theme(legend.position = "none",
        axis.text.y = element_blank())

plt_sat_surftemp_no3 <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = sat_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("Surface temperature (\u00B0C)") +
  ylab("Saturation ratio") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_fill_brewer(palette = "Greys", guide = "none") +
  theme(legend.position = "none")

legend1 <- effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  theme_void() +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(legend.position = c(0.5, 0.1),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = expression(paste("NO"[3], " category"))) +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 0.5))

legend1 <- ggpubr::get_legend(legend1)

legend2 <- 
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  theme_void() +
  theme(legend.position = c(0.5, 0.5),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = "Surface temperature (\u00B0C)") +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 1))

legend2 <- ggpubr::get_legend(legend2)

legendPlot <- ggarrange(legend1, legend2, ncol = 1)

plt_surftemp_effects <- ggarrange(plt_n2oeq_surftemp,
                                  legendPlot,
                                  plt_n2o_surftemp_no3,
                                  plt_n2o_no3_surftemp,
                                  plt_sat_surftemp_no3,
                                  plt_sat_no3_surftemp,
                             ncol = 2,
                             nrow = 3,
                             widths = c(1, 1, 1, 1, 1, 1),
                             heights = c(1, 1, 1, 1, 1, 1),
                             labels = c("A", "Legend", "B", "C", "D", "E"),
                             hjust = c(-6, -1, -6, -6, -6, -6),
                             vjust = c(2, 2, 2, 2, 2, 2)
                             )

plt_surftemp_effects <- plt_surftemp_effects %>%
  annotate_figure(plt_surftemp_effects,
                  left = text_grob("Posterior mean", 
                                   size = 18, 
                                   rot = 90)
                  )

# ggsave only works in R console (i.e., copy + paste to save)
ggsave(filename = "cond_effect_surftemp_no3.tif",
       plot = plt_surftemp_effects,
       device = "tiff",
       width = 180 / 25.4,
       height = 210 / 25.4,
       units = "in")
```

```{r plot_surftemp_effects, echo=FALSE, fig.align='center', fig.asp=1.166667, fig.width=8}
plt_surftemp_effects
```

```{r conditional_effects_mod_n2osat_area_F, echo=FALSE, message=FALSE, warning=FALSE, cache.lazy = FALSE}
effect_no3_area <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               log_area = round(quantile(df_model$log_area, 
                                                   probs = seq(0.10, 0.90, 0.2)), 0),
                               surftemp = mean(df_model$surftemp),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         log_area = factor(log_area))

effect_area_no3 <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               log_area = seq(range(df_model$log_area)[1],
                                              range(df_model$log_area)[2],
                                              length.out = 101),
                               surftemp = mean(df_model$surftemp),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         log_area = log_area)

plt_n2oeq_area <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = n2oeq_pred),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Equilibrium N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 20), breaks = seq(0, 20, 5)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Greys", guide = "none")


plt_n2o_area_no3 <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("") +
  ylab(expression(paste("Dissolved N"[2], "O (nmol/L)"))) +
  theme_pubr() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(axis.text.x = element_blank(),
        legend.position = "none")

plt_n2o_no3_area <-
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab("") +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 55), breaks = seq(0, 50, 10)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

plt_sat_no3_area <-
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = sat_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  xlab(expression(paste("NO"[3], " category"))) +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  theme(legend.position = "none",
        axis.text.y = element_blank())

plt_sat_area_no3 <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = sat_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  xlab("log(surface area (ha))") +
  ylab("Saturation ratio") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_fill_brewer(palette = "Greys", guide = "none") +
  theme(legend.position = "none")

legend1 <- effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = n2o_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  theme_void() +
  scale_fill_brewer(palette = "Greys", guide = "none") + 
  theme(legend.position = c(0.5, 0.1),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = expression(paste("NO"[3], " category"))) +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 0.5))

legend1 <- ggpubr::get_legend(legend1)

legend2 <- 
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = n2o_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  theme_void() +
  theme(legend.position = c(0.5, 0.5),
        legend.direction = "horizontal",
        legend.text = element_text(size = 10, angle = 45)) +
  labs(color = "log(surface area (ha))") +
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, title.vjust = 1))

legend2 <- ggpubr::get_legend(legend2)

legendPlot <- ggarrange(legend1, legend2, ncol = 1)

plt_area_effects <- ggarrange(plt_n2oeq_area,
                                  legendPlot,
                                  plt_n2o_area_no3,
                                  plt_n2o_no3_area,
                                  plt_sat_area_no3,
                                  plt_sat_no3_area,
                             ncol = 2,
                             nrow = 3,
                             widths = c(1, 1, 1, 1, 1, 1),
                             heights = c(1, 1, 1, 1, 1, 1),
                             labels = c("A", "Legend", "B", "C", "D", "E"),
                             hjust = c(-6, -1, -6, -6, -6, -6),
                             vjust = c(2, 2, 2, 2, 2, 2)
                             )

plt_area_effects <- plt_area_effects %>%
  annotate_figure(plt_area_effects,
                  left = text_grob("Posterior mean", 
                                   size = 18, 
                                   rot = 90)
                  )
# ggsave only works in R console (i.e., copy + paste to save)
ggsave(filename = "cond_effect_area_no3.tif",
       plot = plt_area_effects,
       device = "tiff",
       width = 180 / 25.4,
       height = 210 / 25.4,
       units = "in")
```

```{r plot_area_effects, fig.align='center', fig.asp=1.166667, fig.width=8}
plt_area_effects
```

```{r conditional_effects_mod_n2osat_temp_area_F, echo=FALSE, message=FALSE, warning=FALSE, cache.lazy=FALSE}
effect_no3_surftemp <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               surftemp = round(quantile(df_model$surftemp, 
                                                   probs = seq(0.10, 0.90, 0.2)), 0),
                               log_area = mean(df_model$log_area),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         surftemp = factor(surftemp))

effect_surftemp_no3 <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               surftemp = seq(range(df_model$surftemp)[1],
                                              range(df_model$surftemp)[2],
                                              length.out = 101),
                               log_area = mean(df_model$log_area),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         surftemp = surftemp)


effect_no3_area <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               log_area = round(quantile(df_model$log_area, 
                                                   probs = seq(0.10, 0.90, 0.2)), 0),
                               surftemp = mean(df_model$surftemp),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         log_area = factor(log_area))

effect_area_no3 <- expand.grid(no3_cat = levels(df_model$no3_cat),
                               log_area = seq(range(df_model$log_area)[1],
                                              range(df_model$log_area)[2],
                                              length.out = 101),
                               surftemp = mean(df_model$surftemp),
                               log_elev = mean(df_model$log_elev)) %>%
  add_epred_draws(n2o_mod6, resp = c("n2o", "n2oeq"), re_formula = ~ 1) %>%
  pivot_wider(names_from = .category, values_from = .epred) %>%
  mutate(n2o_pred = n2o,
         n2oeq_pred = n2oeq,
         sat_pred = n2o / n2oeq,
         log_area = log_area)

plt_sat_no3_temp <-
  effect_no3_surftemp %>%
  ggplot(aes(x = no3_cat, 
             y = sat_pred, 
             group = surftemp,
             color = surftemp)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  scale_color_brewer(palette = "PuBu") +
  xlab(expression(paste("NO"[3], " category"))) +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  theme(legend.position = c(0.4, 0.6),
        axis.text.y = element_blank()) +
  labs(color = "Surface temperature (\u00B0C)")

plt_sat_temp_no3 <-
  effect_surftemp_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = surftemp,
                      y = sat_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  scale_color_brewer(palette = "OrRd") +
  xlab("Surface temperature (\u00B0C)") +
  ylab("Saturation ratio") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_fill_brewer(palette = "Greys", guide = "none") +
  theme(legend.position = c(0.4, 0.6)) + 
  labs(color = expression(paste("NO"[3], " category")))

plt_sat_no3_area <-
  effect_no3_area %>%
  ggplot(aes(x = no3_cat, 
             y = sat_pred, 
             group = log_area,
             color = log_area)) +
  stat_pointinterval(shape = 95,
                     point_interval = "median_qi",
                     position = position_dodge(width = 1.4, preserve = "single")) +
  scale_color_brewer(palette = "Greys") +
  xlab(expression(paste("NO"[3], " category"))) +
  ylab("") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  theme(legend.position = c(0.4, 0.6),
        axis.text.y = element_blank()) +
  labs(color = "log(surface area (ha))")

plt_sat_area_no3 <-
  effect_area_no3 %>%
  ggplot() +
  stat_lineribbon(aes(x = log_area,
                      y = sat_pred, 
                      group = no3_cat,
                      color = no3_cat),
                  point_interval = "median_qi",
                  show.legend = TRUE,
                  size = 0.7,
                  .width = 0.95) +
  scale_color_brewer(palette = "OrRd") +
  xlab("log(surface area (ha))") +
  ylab("Saturation ratio") +
  theme_pubr() +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = seq(0, 7, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_fill_brewer(palette = "Greys", guide = "none") +
  theme(legend.position = c(0.6, 0.6)) + 
  labs(color = expression(paste("NO"[3], " category")))

plt_temp_area_effects <- ggarrange(plt_sat_temp_no3,
                                  plt_sat_no3_temp,
                                  plt_sat_area_no3,
                                  plt_sat_no3_area,
                             ncol = 2,
                             nrow = 2,
                             widths = c(0.9, 0.9, 0.9, 0.9),
                             heights = c(0.9, 0.9, 0.9, 0.9),
                             labels = c("A", "B", "C", "D"),
                             hjust = -7,
                             vjust = 3
                             )

plt_temp_area_effects <- plt_temp_area_effects %>%
  annotate_figure(plt_temp_area_effects,
                  left = text_grob("Derived posterior mean", 
                                   size = 18, 
                                   rot = 90)
                  )

# ggsave only works in R console (i.e., copy + paste to save)
ggsave(filename = "cond_effect_no3.tif",
       plot = plt_temp_area_effects,
       device = "tiff",
       width = 210 / 25.4,
       height = 210 / 25.4,
       units = "in",
       bg = "white")
```

```{r plot_temp_area_effects, fig.align='center', fig.asp=1.166667, fig.width=8}
plt_temp_area_effects
```

# Predict to population

As mentioned above, in order to make inferences to the population of
interest, the final model above was used to, first, predict surface
temperature in the target population, since it depended only on the
fully observed covariates. Next, the predictive distribution for surface
temperature was used, along with the relevant fully observed covariates,
to predict NO3 in the target population. Finally, the predictive
distributions for temperature and NO3 were used to predict the N2O
responses. The code for these steps is outlined in the following.

The first step used the final model to predict surface temperature to
the population:

```{r predict_obsframe, eval=FALSE, include=TRUE}
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/sframe.rda")
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/n2o_mod6.rda")

predict_temp <- sframe %>%
  mutate(jdate = 205) %>%
  add_predicted_draws(n2o_mod6, resp=c("surftemp"), 
                      allow_new_levels = TRUE, 
                      cores =1, 
                      ndraws = 2000) %>%
  mutate(surftemp = .prediction)

save(predict_temp, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_temp_b.rda")
```

NO3 was next predicted using the posterior predictions for surface
temperature and the other fully observed covariates. Note that only one
posterior draw per posterior predictive draw for surface temperature was
used in order to reduce excess simulations.

```{r parallel_predict_draws, eval=FALSE, include=TRUE}
temp_X <- predict_temp %>% # select relevant columns as predictors
  ungroup() %>%
  arrange(.draw) %>%
  select(.row, .draw, WSA9, state, size_cat, log_area, log_elev, surftemp)


rm(predict_temp) # reduce memory
gc()

# set number of cores to use for parallel predictions
# and register the workers
cl <- parallel::makeCluster(25)
doSNOW::registerDoSNOW(cl) 

# make a progress bar
pb <- txtProgressBar(max = 2000, 
                     style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

system.time( # approx x hrs with 25 workers & 1 draw from PPD
predict_no3 <- foreach(sub_X = isplitRows(temp_X, chunkSize = 465897), 
                       .combine = 'c',
                       .packages = c("brms"),
                       .options.snow = opts
                       ) %dopar% {
                         brms::posterior_predict(n2o_mod6,
                                                 newdata = sub_X,
                                                 resp = "no3cat",
                                                 allow_new_levels = T,
                                                 ndraws = 1,
                                                 cores = 1)
                         }
)

close(pb)
parallel::stopCluster(cl)

save(predict_no3, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_no3_b.rda")
```

Finally, dissolved and equilibrium N2O were predicted using the surface
temperature and NO3 predictions, along with the survey variables and
other fully observed covariates.

```{r n2o_covariates_X, eval=FALSE, include=TRUE}
# re-load the temp predictions into memory
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_temp_b.rda")

# Assemble dataframe containing relevant covariates (known and predicted) for predicting N2O responses.
n2o_X <- predict_temp %>%
  ungroup() %>%
  mutate(no3_cat = predict_no3) %>%
  select(WSA9,
         state,
         size_cat,
         log_area,
         surftemp,
         log_elev,
         no3_cat)

rm(predict_temp, predict_no3) # reduce memory

# set number of cores to use for parallel predictions
# and register the workers
cl <- parallel::makeCluster(25) 
doSNOW::registerDoSNOW(cl) 

# make a progress bar
pb <- txtProgressBar(max = 2000, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

# make predictions in parallel
system.time(
predict_n2o <- foreach(sub_X = isplitRows(n2o_X, chunkSize = 465897),
                 .combine = rbind,
                 .options.snow = opts,
                 .packages = c("brms")) %dopar% {
  apply(posterior_predict(n2o_mod6,
                          newdata = sub_X,
                          resp = c("n2o", "n2oeq"),
                          allow_new_levels = T,
                          ndraws = 1,
                          cores = 1), 3, t)
                   }
)

close(pb)
parallel::stopCluster(cl)

colnames(predict_n2o) <- c("n2o", "n2oeq")

save(predict_n2o, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_n2o_b.rda")
```

Finally, the predictions for all four partially observed responses were
assembled into a new dataframe for use in inference:

```{r assemble_predictions, eval=FALSE, include=TRUE}
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_temp_b.rda")
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_no3_b.rda")
load("C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/predict_n2o_b.rda")

all_predictions <- predict_temp %>%
  ungroup() %>%
  mutate(no3cat = predict_no3) %>%
  bind_cols(predict_n2o) %>%
  mutate(n2osat = n2o / n2oeq, # calculate saturation ratio
         .row = rep(1:465897, each = 500),
         .draw = rep(seq(1,500, 1), 465897)) %>%
  mutate(area_ha = exp(log_area)) %>% # include area on ha scale
  select(WSA9,
         state,
         size_cat,
         area_ha,
         lat,
         lon,
         .row,
         .draw,
         surftemp,
         no3cat,
         n2o,
         n2oeq,
         n2osat)

save(all_predictions, file = "C:/Users/rmartin/OneDrive - Environmental Protection Agency (EPA)/Documents/AE_Reservoirs/DissolvedGasNla/modelFiles/all_predictions_b.rda")
```

# Population estimates

A number of estimates for the target population were assembled and
presented below. First, the full posterior predictive distributions for
dissolved N2O, equilibrium N2O, and the saturation ratio were assessed.
These distributions summarized the predicted distribution of
concentrations or ratios for all lakes in the population of interest and
included parameter uncertainty propagated through the model. Next,
population means were assessed, followed by comparisons of some
model-based estimates to previously calculated design-based estimates.

## Posterior predictive distributions

Below, a density plot summarized the posterior predictive distributions
across the target population of lakes. The summaries of the PPDs were
based on 2000 draws. Note that the x-axis was truncated at 50 nmol/L for
a clearer visualization of the bulk of the predictive distribution. For
reference, the max predicted value was 4403.2 nmol/L for dissolved N2O,
20.4 nmol/L for dissolved N2O, and 793.5 for the saturation ratio.

```{r plot_n2o_posterior_preds, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE, cache.lazy=FALSE}
all_predictions %>%
  group_by(.draw) %>% 
  slice_sample(n=1e4) %>% # simple random sample 10k lakes
  ggplot(aes(x = n2o)) +
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  scale_y_log10() +
  xlim(0, 50) +
  xlab("Dissolved N2O concentration") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_n2oeq_posterior_preds, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  slice_sample(n=1e4) %>% # simple random sample 10k lakes
  ggplot(aes(x = n2o)) +
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  scale_y_log10() +
  xlim(0, 50) +
  xlab("Equilibrium N2O concentration") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_sat_posterior_preds, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  slice_sample(n=1e4) %>% # simple random sample 10k lakes
  ggplot(aes(x = n2osat)) +
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  scale_y_log10() +
  xlim(0, 8) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

## Estimated means

### National

Below are density plots summarizing the posterior distribution of
*means* for N2O concentrations and the saturation ratio for all US lakes
and reservoirs \> 4ha in the lower 48 states).

```{r plot_n2o_nat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(mean_n2o = mean(n2o)) %>%
  ggplot(aes(x = mean_n2o)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean dissolved N2O") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_n2oeq_nat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(mean_n2o = mean(n2oeq)) %>%
  ggplot(aes(x = mean_n2o)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean equlilibrium N2O") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_sat_nat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(mean_sat = mean(n2o/n2oeq)) %>%
  ggplot(aes(x = mean_sat)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

To illustrate the skewness in the predictive distribution for the
saturation ratio, an estimate for the median ratio is shown below. The
entire posterior distribution of the mean above was larger than 1, which
represents the boundary of under- *vs.* oversaturation. By comparison,
the posterior estimate of the median below only included values less
than one, suggesting that though the mean saturation ratio was likely
greater than 1, most lakes in the national population were
undersaturated (i.e., ratio less than 1). In distributions with strong
right-skew, the mean can often be considerably larger than the median.

```{r plot_sat_nat_posterior_median, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>% 
  summarise(median_sat = median(n2o/n2oeq)) %>%
  ggplot(aes(x = median_sat)) + 
  stat_dist_slabinterval(.width = c(0.5, 0.95)) +
  xlab("median N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

Below is a plot of the posterior mean estimate for the proportion of
unsaturated lakes at the national scale.

```{r plot_undersat_posterior_mean, echo=FALSE, fig.align='center', fig.asp=1, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row))) %>%
  ggplot(aes(x = prop_sat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  xlab("Proportion of undersaturated waterbodies") +
  ylab("density") +
  theme_tidybayes()
```

### Ecoregion

Below are posterior estimates of the means for dissolved and equilibrium
N2O and the saturation ratio by WSA9 ecoregion.

```{r plot_n2o_wsa9_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = mean_n2o, 
                        y = reorder(ecoregion, mean_n2o)), 
                    quantiles = 100,
                    .width = c(0.5, 0.95)) +
  xlab("mean dissolved N2O") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_n2oeq_wsa9_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2oeq = mean(n2oeq), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = mean_n2oeq, 
                        y = reorder(ecoregion, mean_n2oeq)), 
                    .width = c(0.5, 0.95)) +
  xlab("mean equilibrium N2O") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_sat_wsa9_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_sat = mean(n2o/n2oeq), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = mean_sat,
                        y = reorder(ecoregion, mean_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("mean N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

A plot of the posterior estimates for the median saturation ratio below
indicated that most lakes in each ecoregion were undersaturated (i.e.,
median \< 1).

```{r plot_sat_wsa9_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(median_sat = median(n2o/n2oeq), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = median_sat,
                        y = reorder(ecoregion, median_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("median N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

A plot of the estimates of the proportion of under-saturated lakes by
ecoregion is below. These summaries again suggested that most lakes in
each ecoregion were likely undersaturated (i.e., median \<\< 1).

```{r plot_prop_sat_wsa9_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row)), .groups = "drop") %>%
  mutate(ecoregion = WSA9) %>%
  ggplot() + 
  stat_slabinterval(aes(x = prop_sat,
                        y = reorder(ecoregion, prop_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("Proportion of undersaturated lakes") +
  ylab("density") +
  theme_tidybayes()
```

### State

Comparisons of mean estimates by state are below. Density polygons were
not included to minimize the vertical plot space.

```{r plot_state_mean_n2o, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate = round(median(mean_n2o), 1),
    LCL = round(quantile(mean_n2o, probs = 0.025), 1),
    UCL = round(quantile(mean_n2o, probs = 0.975), 1),
    .groups = "drop") %>% 
  select(state, estimate, LCL, UCL) %>%
  mutate(state = forcats::fct_reorder(state, estimate)) %>%
  ggplot(aes(x = state, y = estimate )) +
  geom_point(position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL),
                 position=position_dodge(width=0.5)) +
  ylab("mean dissolved N2O") +
  scale_y_continuous(position = "left") + 
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

```{r plot_state_mean_n2oeq, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(mean_n2oeq = mean(n2oeq), .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate = round(median(mean_n2oeq), 1),
    LCL = round(quantile(mean_n2oeq, probs = 0.025), 1),
    UCL = round(quantile(mean_n2oeq, probs = 0.975), 1),
    .groups = "drop") %>% 
  select(state, estimate, LCL, UCL) %>%
  mutate(state = forcats::fct_reorder(state, estimate)) %>%
  ggplot(aes(x = state, y = estimate )) +
  geom_point(position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL),
                 position=position_dodge(width=0.5)) +
  ylab("mean equilibrium N2O") +
  scale_y_continuous(position = "left") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

Below is a plot of estimates for the mean (black circles) and median
(grey circles) saturation ratio by state. A horizontal, dashed, black
line is shown at ratio = 1, indicating the boundary for under- *vs.*
oversaturation. Only a few states (e.g., NV, DE) had median estimates
that were 1 or greater, suggesting that, for most states, most lakes
were estimated to be undersaturated.

```{r plot_state_mean_median_sat, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(mean_sat = mean(n2osat), 
            median_sat = median(n2osat),
            .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate_mean = round(median(mean_sat), 4),
    LCL_mean = round(quantile(mean_sat, probs = 0.025), 4),
    UCL_mean = round(quantile(mean_sat, probs = 0.975), 4),
    estimate_median = round(median(median_sat), 4),
    LCL_median = round(quantile(median_sat, probs = 0.025), 4),
    UCL_median = round(quantile(median_sat, probs = 0.975), 4),
    .groups = "drop") %>% 
  select(state, 
         estimate_mean, 
         estimate_median, 
         LCL_mean,
         LCL_median,
         UCL_mean,
         UCL_median) %>%
  mutate(state = forcats::fct_reorder(state, estimate_mean)) %>%
  ggplot(aes(x = state, y = estimate_mean )) +
  geom_point(position=position_dodge(width=0.5),
             size = 2) +
  geom_linerange(aes(ymin = LCL_mean, ymax = UCL_mean),
                 position=position_dodge(width=0.5)) +
  geom_point(aes(x = state, y = estimate_median), 
             position=position_dodge(width=0.5),
             color = "grey",
             size = 2) +
  geom_linerange(aes(ymin = LCL_median, ymax = UCL_median),
                 position=position_dodge(width=0.5),
                 color = "gray") +
  ylab("mean and median N2O saturation ratio") +
  scale_y_continuous(position = "left") +
  geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

Finally, a plot of the estimated proportion of undersaturated lakes for
each state in the target population. Point estimates are the posterior
median of the proportion and bars are the upper and lower boundaries of
the central 95th percentile of the posterior distributions of
proportions.

```{r plot_state_prop_sat, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(state, .draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row)),
            .groups = "drop") %>%
  group_by(state) %>%
  summarise(estimate = round(median(prop_sat), 4),
    LCL = round(quantile(prop_sat, probs = 0.025), 4),
    UCL = round(quantile(prop_sat, probs = 0.975), 4),
    .groups = "drop") %>% 
  select(state, 
         estimate, 
         LCL,
         UCL) %>%
  mutate(state = forcats::fct_reorder(state, estimate)) %>%
  ggplot(aes(x = state, y = estimate)) +
  geom_point(position=position_dodge(width=0.5),
             size = 2) +
  geom_linerange(aes(ymin = LCL, ymax = UCL),
                 position=position_dodge(width=0.5)) +
  ylab("Proportion of undersaturated lakes") +
  scale_y_continuous(position = "left") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

### Size category

The estimated means and medians by size category are below for dissolved
and equilibrium N2O and the saturation ratio.

```{r plot_n2o_size_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2o),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean dissolved N2O") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_n2oeq_size_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2oeq),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  xlab("mean equilibrium N2O") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_sat_size_posterior_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2osat),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
  xlab("mean N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

```{r plot_sat_size_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = median(n2osat),
            .groups = "drop") %>%
  ggplot(aes(x = mean_n2o, y = size_cat)) + 
  stat_slabinterval(.width = c(0.5, 0.95)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
  xlab("median N2O saturation ratio") +
  ylab("density") +
  theme_tidybayes()
```

Mean *vs.* median below.

```{r plot_size_cat_mean_median_sat, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_sat = mean(n2osat), 
            median_sat = median(n2osat),
            .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate_mean = round(median(mean_sat), 2),
    LCL_mean = round(quantile(mean_sat, probs = 0.025), 2),
    UCL_mean = round(quantile(mean_sat, probs = 0.975), 2),
    estimate_median = round(median(median_sat), 2),
    LCL_median = round(quantile(median_sat, probs = 0.025), 2),
    UCL_median = round(quantile(median_sat, probs = 0.975), 2),
    .groups = "drop") %>% 
  select(size_cat, 
         estimate_mean, 
         estimate_median, 
         LCL_mean,
         LCL_median,
         UCL_mean,
         UCL_median) %>%
  mutate(state = forcats::fct_reorder(size_cat, estimate_mean)) %>%
  ggplot(aes(x = size_cat, y = estimate_mean )) +
  geom_point(position=position_dodge(width=0.5),
             size = 2) +
  geom_linerange(aes(ymin = LCL_mean, ymax = UCL_mean),
                 position=position_dodge(width=0.5)) +
  geom_point(aes(x = size_cat, y = estimate_median), 
             position=position_dodge(width=0.5),
             color = "grey",
             size = 2) +
  geom_linerange(aes(ymin = LCL_median, ymax = UCL_median),
                 position=position_dodge(width=0.5),
                 color = "gray") +
  ylab("mean and median N2O saturation ratio") +
  scale_y_continuous(position = "left") +
  geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
  theme_tidybayes() +
  theme(axis.text.x = element_text(size=9, angle=45))
```

And, finally, the estimated proportion of undersaturated lakes in the
target population by size category.

```{r plot_prop_sat_size_cat_posterior_median, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(prop_sat = sum(n2osat < 1) / length(unique(.row)), .groups = "drop") %>%
  ggplot() + 
  stat_slabinterval(aes(x = prop_sat,
                        y = reorder(size_cat, prop_sat)),
                    .width = c(0.5, 0.95)) +
  xlab("Proportion of undersaturated lakes") +
  ylab("density") +
  theme_tidybayes()
```

## Model- *vs.* design-based

Below, estimates from the model-based approach are compared to
previously calculated, design-based estimates. In general, the
model-based estimates were similar to the design-based estimates. The
model-based estimates were typically within the confidence bounds of the
design-based estimates, but with much greater precision. Improved
precision was expected due to the "shrinkage" induced by the multilevel
parameterization, which affords some "borrowing" of information across
the various levels of the survey factors.

### Dissolved N2O

Below, National mean estimates for dissolved N2O from the model and
design-based approaches were compared. The code and results for the 
design-based approach are located at: 
https://github.com/USEPA/DissolvedGasNla/tree/master/scripts

The sample-based estimates were also included as a reference and are
represented by the black, vertical, dashed lines.

```{r import_design_ests, message=FALSE, cache=TRUE}
### Dissolved N2O estimates

n2o_survey_ests <- read.csv(file = "./../inputData/populationEstimates/Survey_Ests_N20_dissolved.csv") %>%
  tibble() %>%
  rename(estimate = Estimate,
         LCL = LCB95Pct,
         UCL = UCB95Pct) %>%
  select(Type, Subpopulation, estimate, LCL, UCL)

# ests by subpopulations
n2o_survey_ecoregion <- n2o_survey_ests %>%
  filter(Type == "AG_ECO9_NM") %>%
  rename(ecoregion = Subpopulation) %>%
  select(ecoregion, estimate, LCL, UCL) %>%
  mutate(ecoregion = recode(ecoregion,
                            "Coastal Plains" = "CPL",
                            "Northern Appalachians" = "NAP",
                            "Northern Plains" = "NPL",
                            "Southern Appalachians" = "SAP",
                            "Southern Plains" = "SPL",
                            "Temperate Plains" = "TPL",
                            "Upper Midwest" = "UMW",
                            "Western Mountains" = "WMT",
                            "Xeric" = "XER"))

n2o_survey_size <- n2o_survey_ests %>%
  filter(Type == "AREA_CAT6") %>%
  rename(size_cat = Subpopulation) %>%
  select(size_cat, estimate, LCL, UCL)

### Saturation ratio estimates
sat_survey_ests <- read.csv(file = "./../inputData/populationEstimates/Survey_Ests_N20_sat.csv") %>%
  tibble() %>%
  rename(estimate = Estimate,
         LCL = LCB95Pct,
         UCL = UCB95Pct) %>%
  select(Type, Subpopulation, estimate, LCL, UCL)
```

```{r n2o_means_national, message=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_n2o = mean(n2o)) %>%
  summarise(estimate = round(median(mean_n2o), 2), # posterior median
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2)) %>% 
  mutate(type = "model") %>%
  bind_rows(cbind(n2o_survey_ests[1, 3:5], type = rep("survey", 1))) %>%
  add_row(estimate = round(mean(df_model$n2o), 2),
          type = "sample") %>%
  print()
```

```{r plot_n2o_means_national, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_n2o = mean(n2o)) %>%
  summarise(estimate = round(median(mean_n2o), 2), # posterior median
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2)) %>% 
  mutate(type = "model") %>%
  bind_rows(cbind(n2o_survey_ests[1, 3:5], type = rep("survey", 1))) %>%
  mutate(cl_width = round(UCL - LCL, 2)) %>%
  ggplot(aes(x = type, y = estimate, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = round(mean(df_model$n2o), 2), 
             linetype = "dashed",
             color = "black") +
  ylab("mean N2O concentration") +
  ggtitle("National estimate comparison") +
  coord_flip() + 
  theme_tidybayes()
```

Below, estimates were compared by ecoregion.

```{r n2o_mean_wsa9, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2o = mean(n2o)) %>%
  group_by(WSA9, .groups = "drop") %>%
  summarise(estimate = round(median(mean_n2o), 2),
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2),
    .groups = "drop") %>% 
  mutate(ecoregion = factor(WSA9)) %>%
  mutate(type = "model") %>%
  select(ecoregion, estimate, LCL, UCL, type) %>%
  mutate(ecoregion = forcats::fct_reorder(ecoregion, estimate)) %>%
  bind_rows(cbind(n2o_survey_ecoregion, type = rep("survey", 9))) %>%
  #bind_rows(cbind(n2o_survey_ests[-10,], type = rep("survey", 9))) %>%
  arrange(ecoregion) %>%
  print()
```

```{r plot_mean_n2o_wsa9, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(WSA9) %>%
  summarise(estimate = round(median(mean_n2o), 2),
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2),
    .groups = "drop") %>% 
  mutate(ecoregion = factor(WSA9)) %>%
  mutate(type = "model") %>%
  select(ecoregion, estimate, LCL, UCL, type) %>%
  mutate(ecoregion = forcats::fct_reorder(ecoregion, estimate)) %>%
  bind_rows(cbind(n2o_survey_ecoregion, type = rep("survey", 9))) %>%
  ggplot(aes(x = ecoregion, y = estimate, group = type, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  coord_flip() + 
  theme_tidybayes() +
  ylab("mean dissolved N2O") +
  ggtitle("Ecoregion estimates comparison")
```

Means were compared according to size categories below.

```{r table_size_mean_n2o, echo=FALSE,message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_n2o), 1),
    LCL = round(quantile(mean_n2o, probs = 0.025), 1),
    UCL = round(quantile(mean_n2o, probs = 0.975), 1),
    .groups = "drop") %>%
  mutate(type = "model") %>%
  bind_rows(cbind(n2o_survey_size, type = rep("survey", 5))) %>%
  mutate(size = factor(size_cat)) %>%
  mutate(size = forcats::fct_reorder(size, estimate)) %>%
  mutate(cl_width = UCL - LCL) %>%
  arrange(size) %>%
  select(size, estimate, LCL, UCL, type) %>% 
  print()
```

```{r plot_size_mean_n2o, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_n2o = mean(n2o), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_n2o), 2),
    LCL = round(quantile(mean_n2o, probs = 0.025), 2),
    UCL = round(quantile(mean_n2o, probs = 0.975), 2),
    .groups = "drop") %>% 
  #mutate(size_cat = factor(size_cat)) %>%
  mutate(type = "model") %>%
  select(size_cat, estimate, LCL, UCL, type) %>%
  bind_rows(cbind(n2o_survey_size, type = rep("survey", 5))) %>%
  mutate(size_cat = forcats::fct_reorder(size_cat, estimate)) %>%
  ggplot(aes(x = size_cat, y = estimate, group = type, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  coord_flip() + 
  theme_tidybayes() +
  ylab("mean dissolved N2O") +
  ggtitle("Size category estimates comparison")
```

### Saturation

Below, the same comparisons were made for the saturation estimates.

```{r table_nat_sat_mean, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_sat = mean(n2osat), .groups = "drop") %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3),
    .groups = "drop") %>% 
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests[10, 2:4], type = rep("survey", 1))) %>%
  add_row(estimate = round(mean(df_model$n2o / df_model$n2o_eq), 3),
          type = "sample") %>%
  print()
```

```{r plot_nat_sat_mean, echo=FALSE, fig.align='center', fig.asp=0.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(.draw) %>%
  summarise(mean_sat = mean(n2osat)) %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3)) %>%  
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests[10, 2:4], type = rep("survey", 1))) %>%
  ggplot(aes(x = type, y = estimate, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = round(mean(df_model$n2o / df_model$n2o_eq), 3), 
             linetype = "dashed",
             color = "black") +
  ylab("mean N2O saturation ratio") +
  ggtitle("National estimates comparison") +
  coord_flip() + 
  theme_tidybayes()
```

```{r plot_wsa9_sat_mean, echo=FALSE, fig.align='center', fig.asp=2, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(WSA9, .draw) %>%
  summarise( mean_sat = mean(n2osat), .groups = "drop") %>%
  group_by(WSA9) %>%
  summarise( estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3),
    .groups = "drop") %>% 
  mutate(ecoregion = factor(WSA9)) %>%
  mutate(type = "model") %>%
  mutate(ecoregion = forcats::fct_reorder(ecoregion, estimate)) %>%
  select(ecoregion, estimate, LCL, UCL, type) %>%
  bind_rows(cbind(sat_survey_ests[-10,], type = rep("survey", 9))) %>%
  mutate(cl_width = UCL - LCL) %>%
  ggplot(aes(x = ecoregion, y = estimate, group = type, color = type)) +
  geom_point(size = 2, position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = 1, color = "lightgrey") +
  ylab("mean N2O saturation ratio") +
  ggtitle("Ecoregion estimates comparison") +
  coord_flip() + 
  theme_tidybayes()
```

```{r table_size_sat_mean, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_sat = mean(n2osat), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3)) %>%
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests_size, type = rep("survey", 5))) %>%
  mutate(size = factor(size_cat)) %>%
  mutate(cl_width = UCL - LCL) %>%
  arrange(size) %>%
  select(size, estimate, LCL, UCL, type) %>% 
  print()
```

```{r plot_size_sat_mean, echo=FALSE, fig.align='center', fig.asp=1.5, fig.width=5, message=FALSE, warning=FALSE, cache=TRUE}
all_predictions %>%
  group_by(size_cat, .draw) %>%
  summarise(mean_sat = mean(n2osat), .groups = "drop") %>%
  group_by(size_cat) %>%
  summarise(estimate = round(median(mean_sat), 3),
    LCL = round(quantile(mean_sat, probs = 0.025), 3),
    UCL = round(quantile(mean_sat, probs = 0.975), 3),
    .groups = "drop") %>%
  mutate(type = "model") %>%
  bind_rows(cbind(sat_survey_ests_size, type = rep("survey", 5))) %>%
  mutate(size = factor(size_cat)) %>%
  select(size, estimate, LCL, UCL, type) %>% 
  ggplot(aes(x = size, y = estimate, group = type, color = type)) +
  geom_point(position=position_dodge(width=0.5)) +
  geom_linerange(aes(ymin = LCL, ymax = UCL) , position=position_dodge(width=0.5)) +
  scale_colour_manual(values = c("black", "grey")) +
  geom_hline(yintercept = 1, color = "lightgrey") +
  ylab("mean N2O saturation ratio") +
  ggtitle("Size category estimates comparison") +
  coord_flip() + 
  theme_tidybayes()
```

# Session Info

```{r session}
sessionInfo()
```

# References
